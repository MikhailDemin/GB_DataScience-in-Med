Python
Материал из Википедии — свободной энциклопедии
Текущая версия страницы пока не проверялась опытными участниками и может значительно отличаться от версии, проверенной 20 мая 2022 года; проверки требуют 4 правки.
Перейти к навигацииПерейти к поиску
У этого термина существуют и другие значения, см. Python (значения).
Python
Изображение логотипа
Класс языка	объектно-ориентированный язык программирования
Появился в	20 февраля 1991[15]
Автор	Гвидо ван Россум[1]
Разработчик	Python Software Foundation и Гвидо ван Россум[1]
Расширение файлов	.py, .pyc[16], .pyd[17], .pyo[18], .pyw[19], .pyz[20] или .pyi[21]
Выпуск	
3.10.5 (6 июня 2022)[2]
Испытал влияние	ABC,[3] Ada,[4] Алгол 68,[5] APL,[6] C,[7] C++,[8] Клу,[9] Dylan,[10] Haskell,[11] Icon,[12] Java,[13]Лисп,[14] Модула-3,[8] Perl, Standard ML[6]
Лицензия	Python Software Foundation License[1]
Сайт	python.org​ (англ.)
Платформа	Microsoft Windows
ОС	кроссплатформенность[22]
Логотип Викисклада Медиафайлы на Викискладе
Python (МФА: [ˈpʌɪθ(ə)n]; в русском языке встречаются названия пито́н[23] или па́йтон[24]) — высокоуровневый язык программирования общего назначения с динамической строгой типизацией и автоматическим управлением памятью[25][26], ориентированный на повышение производительности разработчика, читаемости кода и его качества, а также на обеспечение переносимости написанных на нём программ[27]. Язык является полностью объектно-ориентированным в том плане, что всё является объектами[25]. Необычной особенностью языка является выделение блоков кода пробельными отступами[28]. Синтаксис ядра языка минималистичен, за счёт чего на практике редко возникает необходимость обращаться к документации[27]. Сам же язык известен как интерпретируемый и используется в том числе для написания скриптов[25]. Недостатками языка являются зачастую более низкая скорость работы и более высокое потребление памяти написанных на нём программ по сравнению с аналогичным кодом, написанным на компилируемых языках, таких как C или C++[27][25].

Python является мультипарадигмальным языком программирования, поддерживающим императивное, процедурное, структурное, объектно-ориентированное программирование[25], метапрограммирование[29] и функциональное программирование[25]. Задачи обобщённого программирования решаются за счёт динамической типизации[30][31]. Аспектно-ориентированное программирование частично поддерживается через декораторы[32], более полноценная поддержка обеспечивается дополнительными фреймворками[33]. Такие методики как контрактное и логическое программирование можно реализовать с помощью библиотек или расширений[34]. Основные архитектурные черты — динамическая типизация, автоматическое управление памятью[25], полная интроспекция, механизм обработки исключений, поддержка многопоточных вычислений с глобальной блокировкой интерпретатора (GIL)[35], высокоуровневые структуры данных. Поддерживается разбиение программ на модули, которые, в свою очередь, могут объединяться в пакеты[36].

Эталонной реализацией Python является интерпретатор CPython, который поддерживает большинство активно используемых платформ[37] и являющийся стандартом де-факто языка[38]. Он распространяется под свободной лицензией Python Software Foundation License, позволяющей использовать его без ограничений в любых приложениях, включая проприетарные[39]. CPython компилирует исходные тексты в высокоуровневый байт-код, который исполняется в стековой виртуальной машине[40]. К другим трём основным реализациям языка относятся Jython (для JVM), IronPython (для CLR/.NET) и PyPy[25][41]. PyPy написан на подмножестве языка Python (RPython) и разрабатывался как альтернатива CPython с целью повышения скорости исполнения программ, в том числе за счёт использования JIT-компиляции[41]. Поддержка версии Python 2 закончилась в 2020 году[42]. На текущий момент активно развивается версия языка Python 3[43]. Разработка языка ведётся через предложения по расширению языка PEP (англ. Python Enhancement Proposal), в которых описываются нововведения, делаются корректировки согласно обратной связи от сообщества и документируются итоговые решения[44].

Стандартная библиотека включает большой набор полезных переносимых функций, начиная с возможностей для работы с текстом и заканчивая средствами для написания сетевых приложений. Дополнительные возможности, такие как математическое моделирование, работа с оборудованием, написание веб-приложений или разработка игр, могут реализовываться посредством обширного количества сторонних библиотек, а также интеграцией библиотек, написанных на Си или C++, при этом и сам интерпретатор Python может интегрироваться в проекты, написанные на этих языках[25]. Существует и специализированный репозиторий программного обеспечения, написанного на Python, — PyPI[45]. Данный репозиторий предоставляет средства для простой установки пакетов в операционную систему и стал стандартом де-факто для Python[46]. По состоянию на 2019 год в нём содержалось более 175 тысяч пакетов[45].

Python стал одним из самых популярных языков, он используется в анализе данных, машинном обучении, DevOps и веб-разработке, а также в других сферах, включая разработку игр. За счёт читабельности, простого синтаксиса и отсутствия необходимости в компиляции язык хорошо подходит для обучения программированию, позволяя концентрироваться на изучении алгоритмов, концептов и парадигм. Отладка же и экспериментирование в значительной степени облегчаются тем фактом, что язык является интерпретируемым[47][25]. Применяется язык многими крупными компаниями, такими как Google или Facebook[25]. По состоянию на октябрь 2021 года Python занимает первое место в рейтинге TIOBE популярности языков программирования с показателем 11,27%[48]. «Языком года» по версии TIOBE Python объявлялся в 2007, 2010, 2018 и 2020 годах[49].


Содержание
1	История
2	Концепция и философия
3	Портируемость
4	Типы и структуры данных
5	Синтаксис и семантика
5.1	Операторы
5.2	Система отступов
5.3	Выражения
5.4	Имена
5.5	Строки документации
6	Парадигмы программирования
6.1	Объектно-ориентированное программирование
6.2	Обобщённое программирование
6.3	Функциональное программирование
6.4	Метапрограммирование
7	Возможности
7.1	Модули и пакеты
7.2	Интроспекция
7.3	Обработка исключений
7.4	Итераторы
7.5	Генераторы
7.6	Управление контекстом выполнения
7.7	Декораторы
7.8	Регулярные выражения
8	Библиотеки
8.1	Стандартная библиотека
8.2	Модули расширения и программные интерфейсы
8.3	Графические библиотеки
8.4	Контроль типов и перегрузка функций
9	Примеры программ
10	Профилирование и оптимизация кода
11	Сравнение с другими языками
11.1	C++ и Java
11.2	Go
11.3	Perl
11.4	PHP
11.5	Lua
11.6	MATLAB и R
11.7	Языки, на которые повлиял Python
12	Критика
12.1	Низкое быстродействие
12.2	Глобальная блокировка интерпретатора (GIL)
12.3	Синтаксис и семантика
12.4	Невозможность модификации встроенных классов
13	Реализации
13.1	CPython
13.2	PyPy
13.3	Jython
13.4	Другие реализации
14	Специализированные подмножества/расширения Python
15	Инструменты поддержки программирования
15.1	Интерактивный режим
15.2	IDE
16	Применение
17	См. также
18	Примечания
18.1	Комментарии
18.2	Источники
19	Литература
20	Ссылки
История
Основная статья: История языка программирования Python

Логотип, использовавшийся с 1990-х до 2006 года

Гвидо Ван Россум
Задумка по реализации языка появилась в конце 1980-х годов, а разработка его реализации началась в 1989 году сотрудником голландского института CWI Гвидо ван Россумом[44]. Для распределённой операционной системы Amoeba требовался расширяемый скриптовый язык, и Гвидо начал разрабатывать Python на досуге, позаимствовав некоторые наработки для языка ABC (Гвидо участвовал в разработке этого языка, ориентированного на обучение программированию). В феврале 1991 года Гвидо опубликовал исходный текст в группе новостей alt.sources[50]. С самого начала Python проектировался как объектно-ориентированный язык.

Гвидо ван Россум назвал язык в честь популярного британского комедийного телешоу 1970-х «Летающий цирк Монти Пайтона»[51], поскольку автор был поклонником этого телешоу, как и многие другие разработчики того времени, а в самом шоу прослеживалась некая параллель с миром компьютерной техники[27].

Наличие дружелюбного, отзывчивого сообщества пользователей считается, наряду с дизайнерской интуицией Гвидо, одним из факторов успеха Python. Развитие языка происходит согласно чётко регламентированному процессу создания, обсуждения, отбора и реализации документов PEP (англ. Python Enhancement Proposal) — предложений по развитию Python[52].

3 декабря 2008 года[53], после длительного тестирования, вышла первая версия Python 3000 (или Python 3.0, также используется сокращение Py3k). В Python 3000 устранены многие недостатки архитектуры с максимально возможным (но не полным) сохранением совместимости со старыми версиями Python.

Дата окончания срока поддержки Python 2.7 первоначально была установлена на 2015 год, а затем перенесена на 2020 год из опасения, что большая часть существующего кода не может быть легко перенесена на Python 3[54][55]. Поддержка Python 2 была направлена лишь на уже существующие проекты, новые проекты должны были использовать Python 3[43]. Больше никаких исправлений безопасности или других улучшений для Python 2.7 не будет выпущено[42][56]. С окончанием срока службы Python 2.x поддерживаются только Python 3.6.x и более поздние версии[57].

Концепция и философия

Пиктограмма для файлов .py
Язык использует динамическую типизацию вместе с подсчётом ссылок и циклический сборщик мусора для менеджмента памяти[58]. Также есть динамические разрешения имен (динамическое связывание), которые связывают имена методов и переменных во время выполнения программы.

Python предлагает поддержку функционального программирования в традициях Лиспа. Так, в Python есть функции filter, map и reduce; также из Лиспа были заимствованы понятия характеристик списков, ассоциативных массивов (словарей), множеств и генераторов списков[59]. Стандартная библиотека содержит два модуля (itertools и functools), реализующие инструменты, заимствованные из Haskell и Standard ML[60].

Разработчики языка Python придерживаются определённой философии программирования, называемой «The Zen of Python» («Дзен Пито́на», или «Дзен Па́йтона»)[61]. Её текст выдаётся интерпретатором Python по команде import this (работает один раз за сессию). Автором этой философии считается Тим Петерс (Tim Peters).

Философия начинается так[62]:

Красивое лучше, чем уродливое.
Явное лучше, чем неявное.
Простое лучше, чем сложное.
Сложное лучше, чем запутанное.
….

Оригинальный текст (англ.)[показать]
Вместо того, чтобы встроить в ядро Python всю функциональность языка, он был спроектирован таким образом, чтобы быть легко расширяемым. Это сделало язык популярным средством добавления программируемых интерфейсов к существующим приложениям. Видение Гвидо Ван Россума маленького ядра с большой стандартной библиотекой и легко расширяемым интерпретатором проистекало из негативного опыта разработки языка ABC, который придерживался противоположного подхода[63].

Python стремится к более простому, менее громоздкому синтаксису и грамматике, предоставляя разработчикам выбор в их методологии кодирования. В отличие от девиза Perl «есть несколько способов сделать это», Python придерживается философии «должен существовать один — и, желательно, только один — очевидный способ сделать это»[64]. Алекс Мартелли[en], член Python Software Foundation, и автор книг по Python пишет, что «Описывать что-то как „умное“ не считается комплиментом в культуре Python»[65].

Разработчики Python стремятся избежать преждевременной оптимизации и отвергают патчи к некритическим частям эталонной реализации CPython, которые могли бы предложить незначительное увеличение скорости за счёт понятности кода[66]. Однако есть способы повышения производительности. Если в программе есть узкие места, связанные с выполнением ресурсоёмких операций на центральном процессоре, но не связанные с использованием операций ввода-вывода, то повысить производительность возможно за счёт трансляции программы при помощи Cython в язык Си и последующей компиляции[67]. Требовательные к вычислительным ресурсам части программы также можно переписывать на язык Си и подключать как отдельные библиотеки с привязками к Python[41].

Важная цель разработчиков Python — делать его забавным для использования. Это было отражено в названии языка, данном в честь Монти Пайтона[51]. Также это отражено в иногда игривом подходе к обучающим программам и справочным материалам, таким как примеры программ из документаций, которые используют названия spam и eggs вместо использующихся в документации множества других языков foo и bar[68][69].

Портируемость
Python портирован и работает почти на всех известных платформах — от КПК до мейнфреймов. Существуют порты под Microsoft Windows, практически под все варианты UNIX (включая FreeBSD и Linux), Android[70], Plan 9, Mac OS и macOS, iPhone OS (iOS) 2.0 и выше, iPadOS, Palm OS, OS/2, Amiga, HaikuOS, AS/400, OS/390, Windows Mobile и Symbian.

По мере устаревания платформы её поддержка в основной ветви языка прекращается. Например, с версии 2.6 прекращена поддержка Windows 95, Windows 98 и Windows ME[71]. В версии 3.5 перестала поддерживаться Windows XP[72] В версии 3.9 перестала поддерживаться Windows Vista и Windows 7[73].

При этом, в отличие от многих портируемых систем, для всех основных платформ Python имеет поддержку характерных для данной платформы технологий (например, Microsoft COM/DCOM). Более того, существует специальная версия Python для виртуальной машины Java — Jython, что позволяет интерпретатору выполняться на любой системе, поддерживающей Java, при этом классы Java могут непосредственно использоваться из Python и даже быть написанными на Python. Также несколько проектов обеспечивают интеграцию с платформой Microsoft.NET, основные из которых — IronPython и Python.Net.

Типы и структуры данных
Python 3. The standard type hierarchy.png
Python поддерживает динамическую типизацию, то есть тип переменной определяется только во время исполнения. Поэтому вместо «присваивания значения переменной» лучше говорить о «связывании значения с некоторым именем». К примитивным типам в Python относятся булевый, целое число произвольной точности, число с плавающей запятой и комплексное число. Из контейнерных типов в Python встроены: строка, список, кортеж, словарь и множество[47]. Все значения являются объектами, в том числе функции, методы, модули, классы.

Добавить новый тип можно либо написав класс (class), либо определив новый тип в модуле расширения (например, написанном на языке C). Система классов поддерживает наследование (одиночное и множественное) и метапрограммирование. Возможно наследование от большинства встроенных типов и типов расширений.

Типы, используемые в Python
Тип	Изменяемость	Описание	Примеры
bool	Неизменяемый	Логический тип	True
False
bytearray	Изменяемый	Массив байтов	bytearray(b'Some ASCII')
bytearray(b"Some ASCII")
bytearray([119, 105, 107, 105])
bytes	Неизменяемый	Массив байтов	b'Some ASCII'
b"Some ASCII"
bytes([119, 105, 107, 105])
complex	Неизменяемый	Комплексное число	3+2.7j
dict	Изменяемый	Словарь (ассоциативный массив), представляет собой коллекцию пар «ключ—значение»; значение может быть любого типа, ключ должен иметь хешируемый тип	{'key1': 1.0, 3: False}
{}
ellipsis[К 1]	Неизменяемый	Многоточие[en] (элипсис). Используется в основном в NumPy для сокращённого задания среза многомерного массива. В самом Python присутствует для поддержки пользовательских типов и таких расширений, как NumPy[74]	...
Ellipsis
Для NumPy:
x[i, ..., j],
что эквивалентно
x[i, :, :, j][74]
float	Неизменяемый	Число с плавающей запятой. Степень точности зависит от платформы, но на практике обычно реализуется в виде 64-битного 53-разрядного числа[75]	
1.414

frozenset	Неизменяемый	Неупорядочное множество, не содержит дубликатов; может содержать внутри себя различные хешируемые типы данных	frozenset([4.0, 'string', True])
int	Неизменяемый	Целое число неограниченного размера[76]	42
list	Изменяемый	Список, может содержать внутри себя различные типы данных	[4.0, 'string', True]
[]
NoneType[К 1]	Неизменяемый	Объект, представляющий собой отсутствие значения, часто называемый Null[en] в других языках.	None
NotImplementedType[К 1]	Неизменяемый	Объект, который возвращается при перегрузке операторов, когда типы операндов не поддерживаются.	NotImplemented
range	Неизменяемый	Последовательность целых чисел от какого-то одного значения до другого, обычно используется для повторения операции несколько раз при помощи for[77]	range(1, 10)
range(10, -5, -2)
set	Изменяемый	Неупорядочное множество, не содержит дубликатов; может содержать внутри себя различные хешируемые типы данных	{4.0, 'string', True}
set()
str	Неизменяемый	Строковый тип	'Wikipedia'
"Wikipedia"
"""Spanning
multiple
lines"""
tuple	Неизменяемый	Кортеж. Может содержать внутри себя различные типы данных. Может использоваться в качестве неизменяемого списка и в качестве записей с неименованными полями[78]	В качестве неизменяемого списка:
(4.0, 'string', True)
('single element',)
()
В качестве записей:
lax_coordinates = (33.9425, -118.408056)
city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)[78]
Синтаксис и семантика
Язык обладает чётким и последовательным синтаксисом, продуманной модульностью и масштабируемостью, благодаря чему исходный код написанных на Python программ легко читаем. При передаче аргументов в функции Python использует вызов по соиспользованию (call-by-sharing)[79].

См. также: Синтаксис и семантика Python[en]
Операторы
Набор операторов достаточно традиционен.

Условный оператор if (если). При наличии нескольких условий и альтернатив применяется необязательный блок elif(сокр. от else if) который может повторяться в коде неограниченное число раз. Если ни одно из условий не было соблюдено, то выполняется необязательный блок else (иначе).
Оператор цикла while.
Оператор цикла for.
Операторы обработки исключений try — except — else — finally.
Оператор определения класса class.
Оператор определения функции, метода или генератора def. Внутри возможно применение return (возврат) для возврата из функции или метода, а в случае генератора — yield (давать).
Оператор pass ничего не делает. Используется для пустых блоков кода.
Система отступов
Одной из интересных синтаксических особенностей языка является выделение блоков кода с помощью отступов (пробелов или табуляций), поэтому в Python отсутствуют операторные скобки begin/end, как в языке Паскаль, или фигурные скобки, как в Си. Такой «трюк» позволяет сократить количество строк и символов в программе и приучает к «хорошему» стилю программирования. С другой стороны, поведение и даже корректность программы может зависеть от начальных пробелов в тексте. Тем, кто привык программировать на языках с явным выделением начала и конца блоков, такое поведение поначалу может показаться неинтуитивным и неудобным.

Сам Гвидо писал[80]:
Наверное, самой спорной особенностью Python является использование отступов для группировки операторов, что взято непосредственно из ABC. Это одна из особенностей языка, которая дорога моему сердцу. Это делает код Python более читабельным двумя способами. Во-первых, использование отступов уменьшает визуальное нагромождение и делает программы короче, тем самым сокращая объем внимания, необходимого для восприятия базовой единицы кода. Во-вторых, это даёт программисту меньше свободы в форматировании, тем самым делая возможным более единообразный стиль, что облегчает чтение чужого кода. (Сравните, например, три или четыре различных соглашения о размещении фигурных скобок в Си, каждое из которых имеет сильных сторонников).

Оригинальный текст (англ.)[показать]
Выражения
Состав, синтаксис, ассоциативность и приоритет операций достаточно привычны для языков программирования и призваны минимизировать употребление скобок. Если сравнивать с математикой, то приоритеты операторов зеркалируют соответствующие в математике, при этом оператор присвоения значения = соответствует типографскому ←. Хотя приоритеты операций позволяют не использовать скобки во многих случаях, на анализ больших выражений может тратиться лишнее время, в результате чего в таких случаях выгоднее явно расставлять скобки[43].

Отдельно стоит упомянуть операцию форматирования для строк (работает по аналогии с функцией printf() из Си), которая использует тот же символ, что и взятие остатка от деления:

>>> str_var = "world"
>>> print("Hello, %s" % str_var)
Hello, world
В версии 3.6 были добавлены форматированные строковые литералы, или f-строки, которые делают код более читаемым и лаконичным:

>>> str_var = "world"
>>> print(f"Hello, {str_var}") # вывод с использованием f-строки
Hello, world
Python имеет удобные цепочечные сравнения. Такие условия в программах — не редкость:

1 <= a < 10 and 1 <= b < 20
Кроме того, логические операции (or и and) являются ленивыми: если для вычисления значения операции достаточно первого операнда, этот операнд и является результатом, в противном случае вычисляется второй операнд логической операции. Это основывается на свойствах алгебры логики: например, если один аргумент операции «ИЛИ» (or) является истиной, то и результат этой операции всегда является истиной. В случае, если второй операнд является сложным выражением, это позволяет сократить издержки на его вычисление. Этот факт широко использовался до версии 2.5 вместо условной конструкции:

a < b and "меньше" or "больше или равно"
Встроенные типы данных, как правило, имеют особый синтаксис для своих литералов (записанных в исходном коде констант):

"строка и Юникод-строка одновременно"
'строка и Юникод-строка одновременно'
"""тоже строка и Юникод-строка одновременно"""
True or False  # булевы литералы
3.14  # число с плавающей запятой
0b1010 + 0o12 + 0xA  # числа в двоичной, восьмеричной и шестнадцатеричной системах счисления
1 + 2j  # комплексное число
[1, 2, "a"]  # список
(1, 2, "a")  # кортеж
{'a': 1, 'b': 'B'}  # словарь
{'a', 6, 8.8}  # множество
lambda x: x**2  # анонимная функция
(i for i in range(10)) # генератор
Для списков (и других последовательностей) Python предлагает набор операций над срезами. Особенностью является индексация, которая может показаться новичку странной, но раскрывает свою согласованность по мере использования. Индексы элементов списка начинаются с нуля. Запись среза s[N:M] означает, что в срез попадают все элементы от N включительно до M, не включая. В качестве иллюстрации можно посмотреть пример работы с последовательностями. При этом индекс можно не указывать. Например, запись s[:M] означает, что в срез попадают все элементы с самого начала; запись s[N:] означает, что попадают все элементы до конца среза; запись s[:] означает, что попадают все элементы с начала и до конца.

Имена
Имя (идентификатор) может начинаться с буквы любого алфавита в Юникоде любого регистра или подчёркивания, после чего в имени можно использовать и цифры. В качестве имени нельзя использовать ключевые слова (их список можно узнать по import keyword; print(keyword.kwlist)) и нежелательно переопределять встроенные имена. Имена, начинающиеся с символа подчёркивания, имеют специальное значение[81].

В каждой точке программы интерпретатор имеет доступ к трём пространствам имён (то есть отображениям имён в объекты): локальному, глобальному и встроенному.

Области видимости имён могут быть вложенными друг в друга (внутри определяемой функции видны имена из окружающего блока кода). На практике с областями видимости и связыванием имён связано несколько правил «хорошего тона», о которых можно подробнее узнать из документации.

Строки документации
Python предлагает механизм документирования кода pydoc. В начало каждого модуля, класса, функции вставляется строка документации — docstring (англ.). Строки документации остаются в коде на момент времени исполнения, и в язык встроен доступ к документации[82](переменная __doc__), что используется современными IDE (Интегрированная среда разработки) (например, Eclipse).

В интерактивном режиме можно получить помощь, сгенерировать гипертекстовую документацию по целому модулю или даже применить doctest (англ.) для автоматического тестирования модуля.

Парадигмы программирования
Python — мультипарадигмальный язык программирования. Полностью поддерживаются объектно-ориентированное, структурное[83], обобщённое, функциональное программирование[25] и метапрограммирование[29]. Базовая поддержка аспектно-ориентированного программирования реализуется за счёт метапрограммирования[32]. Множество других методик, в том числе контрактное[84][85] и логическое программирование[86] можно реализовать с помощью расширений.

Объектно-ориентированное программирование
Дизайн языка Python построен вокруг объектно-ориентированной модели программирования. Реализация ООП в Python является хорошо продуманной, но вместе с тем достаточно специфической по сравнению с другими объектно-ориентированными языками. В языке всё является объектами — либо экземплярами классов, либо экземплярами метаклассов. Исключением является базовый встроенный метакласс type. Таким образом, классы на самом деле являются экземплярами метаклассов, а производные метаклассы являются экземплярами метакласса type. Метаклассы являются частью концепции метапрограммирования и предоставляют возможность управления наследованием классов, что позволяет создавать абстрактные классы, регистрировать классы или добавлять в них какой-либо программный интерфейс в рамках библиотеки или фреймворка[29].

Классы по своей сути представляют план или описание того, как создать объект, и хранят в себе описание атрибутов объекта и методов для работы с ним. Парадигма ООП основывается на инкапсуляции, наследовании и полиморфизме[87]. Инкапсуляция в Python представлена возможностью хранения публичных и скрытых атрибутов (полей) в объекте с предоставлением методов для работы с ними[87], при этом на самом деле все атрибуты являются публичными, но для пометки скрытых атрибутов существует соглашение об именовании[88]. Наследование позволяет создавать производные объекты без необходимости повторного написания кода, а полиморфизм заключается в возможности переопределения любых методов объекта (в Python все методы являются виртуальными[88]), а также в перегрузке методов и операторов. Перегрузка методов в Python реализуется за счёт возможности вызова одного и того же метода с разным набором аргументов[87]. Особенностью Python является возможность модифицировать классы после их объявления, добавляя в них новые атрибуты и методы[43], также можно модифицировать и сами объекты, в результате чего классы могут использоваться как структуры для хранения произвольных данных[88].

В Python поддерживается множественное наследование. Само по себе множественное наследование является сложным, и его реализации сталкиваются с проблемами разрешения коллизий имён между родительскими классами и с возможным повторным наследованием от одного и того же класса в иерархии. В Python методы вызываются согласно порядку разрешения методов (MRO), который основан на алгоритме C3-линеаризации[89], в обычных случаях при написании программ не требуется знать принцип работы данного алгоритма, понимание же может потребоваться при создании нетривиальных иерархий классов[90].

Возможности и особенности, специфичные для Python:

Специальные методы, управляющие жизненным циклом объекта: конструкторы, деструкторы.
Перегрузка операторов (всех, кроме is, '.', '=' и символьных логических).
Свойства (имитация поля с помощью функций).
Управление доступом к полям (эмуляция полей и методов, частичный доступ, и т. п.).
Методы для управления наиболее распространёнными операциями (истинностное значение, len(), глубокое копирование, сериализация, итерация по объекту, …).
Полная интроспекция.
Классовые и статические методы, классовые поля.
Классы, вложенные в функции и классы.
Возможность модифицировать объекты во время исполнения программы.
Обобщённое программирование
Языки с поддержкой динамической типизации и объектно-ориентированного программирования обычно не рассматриваются в рамках обобщённого программирования, поскольку задачи обобщённого программирования решаются за счёт отсутствия ограничений на типы данных[30][31]. В Python обобщённое программирование со строгой типизацией достигается использованием средств языка совместно со внешними анализаторами кода[91], такими как Mypy[92].

Функциональное программирование
Несмотря на то, что Python изначально не задумывался как язык функционального программирования[93], Python поддерживает программирование в стиле функционального программирования, в частности[94]:

функция является объектом первого класса,
функции высших порядков,
рекурсия,
фокус на работу со списками,
аналог замыканий,
частичное применение функции с помощью метода partial(),
возможность реализации других средств на самом языке (например, карринг).
Однако, в отличие от большинства языков, непосредственно ориентированных на функциональное программирование, Python не является чистым языком программирования и код не защищён от побочных эффектов[94][95].

В стандартной библиотеке Python существуют специальные пакеты operator и functools для функционального программирования[93].

Метапрограммирование
Пазлинка и перо
Этот раздел статьи ещё не написан.
Согласно замыслу одного или нескольких участников Википедии, на этом месте должен располагаться специальный раздел.
Вы можете помочь проекту, написав этот раздел.
Python поддерживает метапрограммирование[96][29].

Возможности
Модули и пакеты
Программное обеспечение (приложение или библиотека) на Python оформляется в виде модулей, которые в свою очередь могут быть собраны в пакеты. Модули могут располагаться как в каталогах, так и в ZIP-архивах. Модули могут быть двух типов по своему происхождению: модули, написанные на «чистом» Python, и модули расширения (extension modules), написанные на других языках программирования. Например, в стандартной библиотеке есть «чистый» модуль pickle и его аналог на Си: cPickle. Модуль оформляется в виде отдельного файла, а пакет — в виде отдельного каталога. Подключение модуля к программе осуществляется оператором import. После импорта модуль представлен отдельным объектом, дающим доступ к пространству имён модуля. В ходе выполнения программы модуль можно перезагрузить функцией reload().

Интроспекция
Python поддерживает полную интроспекцию времени исполнения[97]. Это означает, что для любого объекта можно получить всю информацию о его внутренней структуре.

Применение интроспекции является важной частью того, что называют pythonic style, и широко применяется в библиотеках и фреймворках Python, таких как PyRO, PLY, Cherry, Django и др., значительно экономя время использующего их программиста.

Необходимые для интроспекции данные хранятся в специальных атрибутах. Так, например, получить все пользовательские атрибуты большинства объектов можно из специального атрибута — словаря (или другого объекта, предоставляющего интерфейс dict) __dict__

 >>> class x(object):pass
 ....
 >>> f = x()
 >>> f.attr = 12
 >>> print(f.__dict__)
 {'attr': 12}
 >>> print(x.__dict__)       # т.к. классы тоже являются экземплярами объекта type
                            # то и они поддерживают этот тип интроспекции
 {'__dict__': <attribute '__dict__' of 'x' objects>, '__module__'.......
Есть также другие атрибуты, имена и назначение которых зависят от объекта:

 >>> def f():pass
 ....
 >>> f.func_code.co_code    # получение байтокода функции
 'd\x00\x00S'
 >>> f.__class__            # специальный атрибут - ссылка на класс данного объекта
 <type 'function'>
Подавляющее большинство атрибутов, поддерживающих интроспекцию, является классовым, и их, в свою очередь, можно получить из obj.__class__.__dict__. Часть информации, унаследованную от базового класса, все объекты используют совместно, что позволяет экономить память.

Для удобства получения интроспективной информации в Python есть модуль inspect[98].

 >>> def f(x,y = 10,**mp):pass
 ...
 >>> inspect.getargspec(f)
 (['x', 'y'], None, 'mp', (10,))
С помощью модуля new возможен обратный процесс — построения объекта из составных частей на этапе исполнения

 >>> def f(i): return j + i
 ....
 >>> j = 2
 >>> f(1)
 3
 >>> import new
 >>> g = new.function(f.func_code, {'j': 23})
 >>> g(1)
 24
Обработка исключений
Обработка исключений поддерживается в Python посредством операторов try, except, else, finally, raise, образующих блок обработки исключения. В общем случае блок выглядит следующим образом:

try:
    # Здесь код, который может вызвать исключение
    raise Exception("message")  # Exception, это один из стандартных типов исключения (всего лишь класс),
                                # может использоваться любой другой, в том числе свой
except (Тип исключения1, Тип исключения2, …) as Переменная:
    # Код в блоке выполняется, если тип исключения совпадает с одним из типов
    # (Тип исключения1, Тип исключения2, …) или является наследником одного
    # из этих типов.
    # Полученное исключение доступно в необязательной Переменной.
except (Тип исключения3, Тип исключения4, …) as Переменная:
    # Количество блоков except не ограничено
    raise  # Сгенерировать исключение "поверх" полученного; без параметров - повторно сгенерировать полученное
except:
    # Будет выполнено при любом исключении, не обработанном типизированными блоками except
else:
    # Код блока выполняется, если не было поймано исключений.
finally:
    # Будет исполнено в любом случае, возможно после соответствующего
    # блока except или else
Совместное использование else, except и finally стало возможно только начиная с Python 2.5. Информация о текущем исключении всегда доступна через sys.exc_info(). Кроме значения исключения, Python также сохраняет состояние стека вплоть до точки возбуждения исключения — так называемый traceback.

В отличие от компилируемых языков программирования, в Python использование исключения не приводит к значительным накладным расходам (а зачастую даже позволяет ускорить исполнение программ) и очень широко используется. Исключения согласуются с философией Python (10-й пункт «дзена Python» — «Ошибки никогда не должны умалчиваться») и являются одним из средств поддержки «утиной типизации».

Иногда вместо явной обработки исключений удобнее использовать блок with (доступен, начиная с Python 2.5).

Итераторы
В программах на Python широко используются итераторы. Цикл for может работать как с последовательностью, так и с итератором. Большинство коллекций предоставляют итераторы, итераторы могут также определяться пользователем для собственных объектов. Модуль itertools стандартной библиотеки содержит средства работы с итераторами.

Генераторы
Одной из интересных возможностей языка являются генераторы — функции, сохраняющие внутреннее состояние: значения локальных переменных и текущую инструкцию (см. также: сопрограммы). Генераторы могут использоваться как итераторы для структур данных и для ленивых вычислений. См. пример: генератор чисел Фибоначчи.

При вызове генератора функция немедленно возвращает объект-итератор, который хранит текущую точку исполнения и состояние локальных переменных функции. При запросе следующего значения (посредством метода next(), неявно вызываемого в цикле for) генератор продолжает исполнение функции от предыдущей точки остановки до следующего оператора yield или return.

В Python 2.4 появились генераторные выражения — выражения, дающие в результате генератор. Генераторные выражения позволяют сэкономить память там, где иначе требовалось бы использовать список с промежуточными результатами:

>>> sum(i for i in range(1, 100) if i % 2 != 0)
2500
В этом примере суммируются все нечётные числа от 1 до 99.

Начиная с версии 2.5, Python поддерживает полноценные сопроцедуры: теперь в генератор можно передавать значения с помощью метода send() и возбуждать в его контексте исключения с помощью метода throw().

Также Python поддерживает вложенные генераторы. Например, для создания двумерного массива нужно разместить генератор списка, являющегося строкой, внутри генератора всех строк: [[0 for j in range(m)] for i in range(n)]

Управление контекстом выполнения
В Python 2.5 появились средства для управления контекстом выполнения блока кода — оператор with и модуль contextlib. См.: пример.

Оператор может применяться в тех случаях, когда до и после некоторых действий должны обязательно выполняться некоторые другие действия, независимо от возбуждённых в блоке исключений или операторов return: файлы должны быть закрыты, ресурсы освобождены, перенаправление стандартного ввода вывода закончено и т. п. Оператор улучшает читаемость кода, а значит, помогает предотвращать ошибки.

Декораторы
Не следует путать с одноимённым шаблоном проектирования.
Пазлинка и перо
Этот раздел статьи ещё не написан.
Согласно замыслу одного или нескольких участников Википедии, на этом месте должен располагаться специальный раздел.
Вы можете помочь проекту, написав этот раздел.
Декораторы функций — вызываемые объекты, которые принимают другую функцию в качестве аргумента. Декораторы функций могут производить операции с функцией и возвращают либо саму функцию, либо другую заменяющую её функцию или вызываемый объект. То есть, если в коде ранее был прописан декоратор, названный decorate, то следующий код[99]:

@decorate
def target():
    print('running target()')
эквивалентен этому[99]:

def target():
    print('running target()')
target = decorate(target)
Пример использования декоратора функции[99]:

>>> def deco(func):
...     def inner():
...         print('running inner()')
...     return inner
…
>>> @deco
... def target():
...     print('running target()')
>>> target()
running inner()
>>> target
<function deco.<locals>.inner at 0.10063b598>
Существуют декораторы классов[100].

Регулярные выражения
Формат регулярных выражений унаследован из Perl с некоторыми отличиями. Для их использования требуется импортировать модуль re[101], являющийся частью стандартной библиотеки.

Библиотеки
Стандартная библиотека
Основная статья: Стандартная библиотека Python

Python поставляется «с батарейками в комплекте». Такую метафору использовали разработчики, чтобы подчеркнуть богатую стандартную библиотеку языка[102]
Богатая стандартная библиотека является одной из привлекательных сторон Python. Здесь имеются средства для работы со многими сетевыми протоколами и форматами Интернета, например, модули для написания HTTP-серверов и клиентов, для разбора и создания почтовых сообщений, для работы с XML и т. п. Набор модулей для работы с операционной системой позволяет писать кросс-платформенные приложения. Существуют модули для работы с регулярными выражениями, текстовыми кодировками, мультимедийными форматами, криптографическими протоколами, архивами, сериализации данных, поддержка юнит-тестирования и др.

Модули расширения и программные интерфейсы
Помимо стандартной библиотеки существует множество библиотек, предоставляющих интерфейс ко всем системным вызовам на разных платформах; в частности, на платформе Win32 поддерживаются все вызовы Win32 API, а также COM в объёме не меньшем, чем у Visual Basic или Delphi. Количество прикладных библиотек для Python в самых разных областях без преувеличения огромно (веб, базы данных, обработка изображений, обработка текста, численные методы, приложения операционной системы и т. д.).

Для Python принята спецификация программного интерфейса к базам данных DB-API 2 и разработаны соответствующие этой спецификации пакеты для доступа к различным СУБД: Oracle, MySQL, PostgreSQL, Sybase, Firebird (Interbase), Informix, Microsoft SQL Server и SQLite. На платформе Windows доступ к БД возможен через ADO (ADOdb). Коммерческий пакет mxODBC для доступа к СУБД через ODBC для платформ Windows и UNIX разработан eGenix[103]. Для Python написано много ORM (SQLObject, SQLAlchemy, Dejavu, Django), выполнены программные каркасы для разработки веб-приложений (Django, Pylons, Pyramid).

Библиотека NumPy для работы с многомерными массивами позволяет иногда достичь производительности научных расчётов, сравнимой со специализированными пакетами. SciPy использует NumPy и предоставляет доступ к обширному спектру математических алгоритмов (матричная алгебра — BLAS уровней 1—3, LAPACK, БПФ…). Numarray[104] специально разработан для операций с большими объёмами научных данных.

WSGI[105] — интерфейс шлюза с веб-сервером (Python Web Server Gateway Interface).

Python предоставляет простой и удобный программный интерфейс C API для написания собственных модулей на языках Си и C++. Такой инструмент как SWIG позволяет почти автоматически получать привязки для использования C/C++ библиотек в коде на Python. Возможности этого и других инструментов варьируются от автоматической генерации (C/C++/Fortran)-Python интерфейсов по специальным файлам (SWIG, pyste[106], SIP[107], pyfort[108]), до предоставления более удобных API (boost::python[109][110], CXX[111], Pyhrol[112] и др.). Инструмент стандартной библиотеки ctypes позволяет программам Python напрямую обращаться к динамическим библиотекам/DLL, написанным на Си. Существуют модули, позволяющие встраивать код на С/C++ прямо в исходные файлы Python, создавая расширения «на лету» (pyinline[113], weave[114]).

Другой подход состоит во встраивании интерпретатора Python в приложения. Python легко встраивается в программы на Java, C/C++, OCaml. Взаимодействие Python-приложений с другими системами возможно также с помощью CORBA, XML-RPC, SOAP, COM.

С помощью проекта Cython возможна трансляция программ, написанных на языках Python и Pyrex, в код на языке Си с последующей компиляцией в машинный код. Cython используется для упрощения написания Python-библиотек, при его использовании отмечается ускорение кода и уменьшение накладных расходов.

Экспериментальный проект Shedskin предполагает создание компилятора для трансформации неявно типизированных Python-программ в оптимизированный С++ код. Начиная с версии 0.22 Shedskin позволяет компилировать отдельные функции в модули расширений.

Python и подавляющее большинство библиотек к нему бесплатны и поставляются в исходных кодах. Более того, в отличие от многих открытых систем, лицензия никак не ограничивает использование Python в коммерческих разработках и не налагает никаких обязательств, кроме указания авторских прав.

Одним из каналов распространения и обновления пакетов для Python является PyPI (англ. Python Package Index).

Графические библиотеки
С Python поставляется библиотека tkinter на основе Tcl/Tk для создания кроссплатформенных программ с графическим интерфейсом.

Существуют расширения, позволяющие использовать все основные библиотеки графических интерфейсов — wxPython[115], основанное на библиотеке wxWidgets, PyGObject для GTK[116], PyQt и PySide для Qt и другие. Некоторые из них также предоставляют широкие возможности по работе с базами данных, графикой и сетями, используя все возможности библиотеки, на которой основаны.

Для создания игр и приложений, требующих нестандартного интерфейса, можно использовать библиотеку Pygame. Она также предоставляет обширные средства работы с мультимедиа: с её помощью можно управлять звуком и изображениями, воспроизводить видео. Предоставляемое pygame аппаратное ускорение графики OpenGL имеет более высокоуровневый интерфейс по сравнению с PyOpenGL[117], копирующей семантику С-библиотеки для OpenGL. Есть также PyOgre[118], обеспечивающая привязку к Ogre — высокоуровневой объектно-ориентированной библиотеке 3D-графики. Кроме того, существует библиотека pythonOCC[119], обеспечивающая привязку к среде 3D-моделирования и симуляции OpenCascade[120].

Для работы с растровой графикой используется библиотека Python Imaging Library.

Для работы с векторной графикой используется PyCairo.

Контроль типов и перегрузка функций
Существуют модули, позволяющие контролировать типы параметров функций на этапе исполнения, например, typecheck[121] или method signature checking decorators[122]. Необязательная декларация типов для параметров функции добавлена в Python 3, интерпретатор при этом не проверяет типы, а только добавляет соответствующую информацию к метаданным функции для последующего использования этой информации модулями расширений[123].

Перегрузка функций реализована различными сторонними библиотеками, в том числе PEAK[124][125]. Планы, которые не были приняты, по поддержке перегрузки в Python3000[126] были частично реализованы в библиотеке overloading-lib[127].

Примеры программ
В статье «Примеры программ на языке Python» Викиверситета собраны примеры небольших программ, демонстрирующих некоторые возможности языка Python и его стандартной библиотеки.

Программа «Hello World!» может быть написана одной строкой:

print("Hello World!")
Вычисление факториала числа 10 (10!):

def factorial(n):
    if n < 0:
        raise ArithmeticError('Факториал отрицательного числа.')
    f = 1
    for i in range (2, n + 1):
        f *= i
    return f

print(factorial(10)) # 3628800
Реализация с помощью рекурсии:

def factorial(n):
    if n < 0:
        raise ArithmeticError('Факториал отрицательного числа.')
    if (n == 0) or (n == 1):
        return 1
    else:
        return factorial(n - 1) * n

print(factorial(10))
Профилирование и оптимизация кода
В стандартной библиотеке Python имеется профайлер (модуль profile), который можно использовать для сбора статистики о времени работы отдельных функций. Для решения вопроса о том, какой вариант кода работает быстрее, можно использовать модуль timeit. Производимые в следующей программе измерения позволяют выяснить, какой из вариантов конкатенации строк более эффективен:

from timeit import Timer

tmp = "Python 3.2.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)] on win32."

def case1(): # А. инкрементальные конкатенации в цикле
    s = ""
    for i in range(10000):
        s += tmp

def case2(): # Б. через промежуточный список и метод join
    s = []
    for i in range(10000):
        s.append(tmp)
    s = "".join(s)

def case3(): # В. списковое выражение и метод join
    return "".join([tmp for i in range(10000)])

def case4(): # Г. генераторное выражение и метод join
    return "".join(tmp for i in range(10000))

for v in range(1,5):
    print (Timer("func()","from __main__ import case%s as func" % v).timeit(200))
Как и в любом языке программирования, в Python имеются свои приёмы оптимизации кода. Оптимизировать код можно исходя из различных (часто конкурирующих друг с другом) критериев (увеличение быстродействия, уменьшение объёма требуемой оперативной памяти, компактность исходного кода и т. д.). Чаще всего программы оптимизируют по времени исполнения.

Здесь есть несколько очевидных для опытных программистов правил.

Не нужно оптимизировать программу, если скорость её выполнения достаточна.
Используемый алгоритм имеет определённую временную сложность, поэтому перед оптимизацией кода программы стоит сначала пересмотреть алгоритм.
Стоит использовать готовые и отлаженные функции и модули, даже если для этого нужно немного обработать данные. Например, в Python есть встроенная функция sorted().
Профилирование поможет выяснить узкие места. Оптимизацию нужно начинать с них.
Python имеет следующие особенности и связанные с ними правила оптимизации.

Вызов функций является достаточно дорогостоящей операцией, поэтому внутри вложенных циклов нужно стараться избегать вызова функций или, например, переносить цикл в функции. Функция, обрабатывающая последовательность, эффективнее, чем обработка той же последовательности в цикле вызовом функции.
Старайтесь вынести из глубоко вложенного цикла всё, что можно вычислить во внешних циклах. Доступ к локальным переменным более быстрый, чем к глобальным или чем доступ к полям.
Оптимизатор psyco может помочь ускорить работу модуля программы при условии, что модуль не использует динамических свойств языка Python.
В случае, если модуль проводит массированную обработку данных и оптимизация алгоритма и кода не помогает, можно переписать критические участки, скажем, на языке Си или Pyrex.
Инструмент под названием Pychecker[128] поможет проанализировать исходный код на Python и выдать рекомендации по найденным проблемам (например, неиспользуемые имена, изменение сигнатуры метода при его перегрузке и т. п.). В ходе такого статического анализа исходного кода могут быть выявлены и ошибки. Pylint[129] призван решать близкие задачи, но имеет уклон в сторону проверки стиля кода, поиска кода с запашком[130].

Сравнение с другими языками
См. также: сравнение языков программирования в виде таблиц
Выбор языка обычно зависит от решаемых задач, особенностей языков и наличия библиотек, требуемых для решения задачи. Одна и та же задача, написанная на разных языках может сильно разниться по эффективности исполнения, в том числе различия могут быть и при исполнении в разных операционных системах или при использовании разных компиляторов. В общем случае языки можно поделить на интерпретируемые (скриптовые), компилируемые в промежуточное представление и компилируемые, что влияет на производительность и потребление памяти. Python принято относить к интерпретируемым. Также отдельные языки могут иметь свои сильные стороны, в случае Python выделяется лёгкость в написании программ[131].

C++ и Java
Python сравнивается с C++/Java с точки зрения лаконичности, простоты и гибкости Python[132]. Можно сравнить «Hello, world»-программы, записанные на каждом из языков[132].

Сравнение программ «Hello, world!»
C++[132]	Java[132]	Python[132]
#include <iostream>
int main() {
    std::cout << "Hello, world!" << std::endl;
    return 0;
}
public class HelloClass {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
print("Hello, world!")
Касательно ООП в Python в отличие от C++ и Java отсутствуют модификаторы доступа к полям и методам класса, атрибуты и поля у объектов могут создаваться на лету в ходе исполнения программы, а все методы являются виртуальными. По сравнению с Java Python позволяет также перегружать операторы, что даёт возможность использовать выражения близкие к естественным[132]. В совокупности подход к ООП в Python упрощает программирование, делает код более понятным и одновременно добавляет гибкости языку[132]. С другой стороны, скорость выполнения кода на Python (как и других интерпретируемых языков) значительно ниже, чем скорость выполнения аналогичного кода на C++[133] и обычно ожидается ниже, чем в Java[134]. Код на C++ получается производительнее Python, при этом занимает больше строк. Согласно исследованиям алгоритов, применяемых в биоинформатике, Python показал себя более гибким чем C++, а Java оказалась компромиссным решением между производительностью C++ и гибкостью Python[131].

В Java и Python все объекты создаются в куче, в то время как C++ позволяет создавать объекты как в куче, так и на стеке, в зависимости от используемого синтаксиса[135]. На производительность также влияет способ доступа к данным в памяти. В C++ и Java доступ к данным происходит по постоянным смещениям в памяти, в то время как в Python — через хеш-таблицы. Использование указателей в C++ может быть довольно сложным для понимания среди новичков, и овладение навыками правильного использования указателей может занять некоторое время[131].

Go
Go и Python — кардинально различающиеся языки, тем не менее, они часто сравниваются один с другим из-за общей ниши — бэкэнда веб-приложений. По выражению Джейсона Кинкэйда, Go объединяет «производительность и безопасность компилируемых языков, таких как C++, со скоростью разработки на динамических языках, таких как Python»[136]. В какой-то мере это действительно так: Go изначально разработан как строго статически типизированный компилируемый язык, поддерживающий максимум возможностей динамических языков, при котором ещё можно обеспечить эффективную компиляцию и сохранить производительность компилируемых программ. Общими для обоих языков является использование автоматического управления памятью, наличие встроенных динамических коллекций (массивов и словарей), поддержка срезов, развитый механизм модулей, простой и минималистичный синтаксис. Различий гораздо больше, и не всегда можно однозначно указать, в пользу какого из языков они говорят.

Динамические возможности.
Если Python является полностью динамическим языком и практически любые элементы программы могут меняться во время исполнения, включая конструирование «на лету» новых типов и модификацию существующих, то Go — статический язык с достаточно ограниченными возможностями рефлексии, работающей только в отношении созданных при разработке типов данных. В некоторой мере заменой динамических возможностей в Go является кодогенерация, обеспечиваемая простотой синтаксиса и наличием необходимых инструментов и системных библиотек. Также в версии Go 2.0 планируется добавить поддержку средств обобщённого программирования (generics).
Объектно-ориентированное программирование.
Python построен по идеологии «всё-объект» и имеет множество механизмов ООП, в том числе редких и нетипичных. Gо — вполне типичный модульный процедурный язык программирования, возможности ООП в котором ограничиваются поддержкой интерфейсов и возможностью встраивания структур и интерфейсов. По сути, в Go нет даже полноценного наследования. Поэтому если Python поощряет программирование в ООП-стиле, с построением древовидных зависимостей между классами и активным использованием наследования, то Go ориентирован на компонентный подход: поведение компонентов задаётся интерфейсами, которые могут быть даже не связаны между собой, а реализация интерфейсов размещается в типах-структурах. «Утиная типизация», реализованная в Go, приводит к тому, что между интерфейсами и реализующими их структурами нет даже формальных синтаксических связей.
Параллельное программирование.
В поддержке параллельного программирования Python существенно уступает Go. Прежде всего, GIL в Python является препятствием для эффективного использования систем с большим числом (десятки и более) физических процессорных ядер. Другой проблемой является отсутствие эффективных встроенных средств взаимодействия параллельных потоков. Go содержит языковой примитив goroutine, позволяющий создавать «легковесные» потоки, и поддерживаемые на уровне синтаксиса каналы, обеспечивающие взаимодействие потоков. В результате при создании, например, систем массового обслуживания на Go не составляет проблемы использование сотен и даже тысяч одновременно существующих потоков, причём с обеспечением нормальной загрузки любого количества доступных процессорных ядер, тогда как ни одна из существующих реализаций Python эффективную работу такого количества потоков не обеспечит.
Обработка ошибок, исключения.
Python поддерживает обработку исключений, тогда как Go реализует механизмы явного возврата кодов ошибок из функций и обработки их в месте вызова. Оценка этого различия может быть разной. С одной стороны, исключения являются удобным и привычным механизмом обработки программных ошибок, позволяющим сосредоточить эту обработку в выделенных фрагментах кода, а не «размазывать» её по всему тексту программы. С другой стороны, авторы Go считают, что программисты слишком часто игнорируют обработку ошибок, полагаясь на то, что возникшее исключение будет обработано в другом месте; в распределённых приложениях исключения часто не передаются между компонентами системы и приводят к неожиданным отказам, а в многопоточных приложениях необработанное исключение в потоке может привести к блокировке или, наоборот, к краху программы.
Изобразительные возможности, синтаксис.
Python предоставляет большее число удобных для быстрой разработки языковых возможностей и примитивов, чем Go. Во многом это связано с тем, что разработчики Go сознательно отказались от включения в язык некоторых «модных» средств, одни из которых сочли провоцирующими ошибки, другие — маскирующими заведомо неэффективную реализацию. Например, наличие в языке простой операции вставки элемента в середину массива провоцирует на её частое использование, а каждая такая операция требует, как минимум, перемещения «хвоста» массива в памяти, а иногда может требовать выделения памяти и перемещения всего массива.
Производительность.
По производительности в большинстве тестов, реализующих типичные наборы операций бэкэнда (обработка запросов, генерация веб-страниц), Go превосходит Python на величину от нескольких раз до нескольких порядков. Это неудивительно ввиду статического характера языка и того, что программы на Go компилируются непосредственно в код целевой платформы. В системах, где основное затрачиваемое время уходит на выполнение запросов к БД или передачу информации по сети, это несущественно, но в высоконагруженных системах, обрабатывающих большое число запросов, преимущество Go бесспорно. Также на разницу в производительности Go- и Python-программ влияют отмеченные выше различия в реализации параллелизма.
Perl
Оба языка являются интерпретируемыми, компилируются в промежуточное представление, которое затем отправляется на исполнение. В случае Python генерируется промежуточный байт-код, а компилятор Perl генерирует синтаксическое дерево. Управление памятью в обоих языках автоматическое, а сами языки используются как скриптовые и хорошо подходят для написания веб-приложений. Подход в написания кода Python предполагает лучшее понимание листинга программы в ущерб производительности, тогда как в Perl больше свободы в синтаксисе, что может привести к тому что программы на Perl становятся нечитабельны для программистов, не работающих с данным языком[131].

PHP
Пазлинка и перо
Этот раздел статьи ещё не написан.
Согласно замыслу одного или нескольких участников Википедии, на этом месте должен располагаться специальный раздел.
Вы можете помочь проекту, написав этот раздел.
Lua
Lua — простой язык, исходно разработанный для встраивания в ПО и использования для автоматизации сложных операций (таких, как поведение ботов в компьютерных играх). Python также может применяться в этих областях, ещё он конкурирует с Lua в написании скриптов автоматизации управления компьютером и операционной системой и в непрофессиональном программировании «на себя». В последние годы оба языка стали встраиваться в мобильные устройства, например, в программируемые калькуляторы.

Оба языка являются динамическими, интерпретируемыми, поддерживают автоматическое управление памятью, имеют стандартные средства взаимодействия с ПО, написанным на других языках (главным образом C и C++). Среда исполнения Lua компактнее и требует для работы меньше ресурсов, чем Python, что даёт Lua преимущество при встраивании. Как и Python, Lua поддерживает компиляцию исходного текста в исполняемый виртуальной машиной байт-код. Существует реализация JIT-компилятора для Lua.

Lua проще, чем Python, и имеет более классический паскалеподобный синтаксис. В языке всего восемь встроенных типов данных, а все структурированные типы (структуры, перечисления, массивы, множества) моделируются на основе единственного встроенного типа «таблица», который фактически является гетерогенным словарём. ООП реализуется на таблицах и строится по прототипной модели, как в JavaScript. Python предоставляет больше возможностей, а его структурированные типы данных имеют каждый свою реализацию, что повышает производительность. Возможности ООП в Python существенно шире, что даёт преимущество при написании сложных программ, но мало влияет на качество и производительность простых скриптов, на которые ориентирован Lua.

MATLAB и R
Пазлинка и перо
Этот раздел статьи ещё не написан.
Согласно замыслу одного или нескольких участников Википедии, на этом месте должен располагаться специальный раздел.
Вы можете помочь проекту, написав этот раздел.
Python, MATLAB и R используются в обработке данных и в обучении студентов основам математики и статистики. R является языком для выполнения статистических расчётов, в то время как MATLAB может считаться языком программирования наряду с Python[137].

Языки, на которые повлиял Python
Python, как весьма популярный язык программирования, повлиял на следующие языки:

CoffeeScript имеет синтаксис, вдохновлённый Python[138].
ECMAScript/JavaScript заимствовал итераторы и генераторы из Python[139].
Go, при сильнейших идеологических различиях, заимствовал у динамических языков, таких как Python, встроенные словари, динамические массивы, срезы.
Groovy был создан с мотивацией привнести философию Python на Java[140].
Julia была задумана как «такая же пригодная для общего программирования, как и Python»[141].
Nim использует систему отступов и аналогичный синтаксис[142].
Ruby — Юкихиро Мацумото, создатель языка, сказал: «Я хотел скриптовый язык, который был бы более мощным, чем Perl, и более объектно-ориентированным, чем Python. Вот почему я решил создать свой собственный язык»[143].
Swift во время разработки брал идеи структуры языка из Python, а также из Objective-C, Rust, Haskell, Ruby, C#, CLU[144].
Критика
Низкое быстродействие
Классический Python имеет общий со многими другими интерпретируемыми языками недостаток — сравнительно невысокую скорость выполнения программ[145]. В некоторой степени ситуацию улучшает сохранение байт-кода (расширения .pyc и, до версии 3.5, .pyo), которое позволяет интерпретатору не тратить время на синтаксический разбор текста модулей при каждом запуске.

Существуют реализации языка Python, вводящие высокопроизводительные виртуальные машины (ВМ) в качестве бэкенда компилятора. Примерами таких реализаций может служить PyPy, базирующийся на RPython; более ранней инициативой является проект Parrot. Ожидается, что использование ВМ типа LLVM приведёт к тем же результатам, что и использование аналогичных подходов для реализаций языка Java, где низкая вычислительная производительность в основном преодолена[146]. Однако нельзя забывать, что динамический характер Python делает неизбежными дополнительные накладные расходы при исполнении программ, что ограничивает производительность Python-систем независимо от применяемых технологий. Вследствие этого для написания критических участков кода используются низкоуровневые языки, интеграция с которыми обеспечивается множеством программ и библиотек (см. выше).

В самой популярной реализации языка Python интерпретатор довольно велик и более требователен к ресурсам, чем в аналогичных популярных реализациях Tcl, Forth, LISP или Lua, что ограничивает его применение во встроенных системах. Тем не менее, Python портирован на некоторые относительно малопроизводительные платформы[источник не указан 439 дней].

Глобальная блокировка интерпретатора (GIL)

Схематичное изображение работы потоков под GIL. Зелёный — поток, удерживающий GIL, красные — блокированные потоки
Основная статья: Global Interpreter Lock
Интерпретатор Python в CPython (а также Stackless и PyPy[147]) использует потоко-небезопасные данные, во избежание разрушения которых при совместной модификации из разных потоков применяется глобальная блокировка интерпретатора — GIL (Global Interpreter Lock)[148]: в ходе исполнения кода поток интерпретатора блокирует GIL, выполняет в течение фиксированного времени (по умолчанию 5 миллисекунд[К 2]) некоторое количество инструкций, после чего освобождает блокировку и приостанавливается, давая возможность работать другим потокам. GIL также освобождается во время ввода-вывода, изменения и проверки состояния синхронизирующих примитивов, при исполнении кода расширений, не обращающихся к данным интерпретатора, например, NumPy/SciPy. Таким образом, в каждый момент времени в одном процессе интерпретатора Python может исполняться только один поток кода на Python, независимо от числа доступных процессорных ядер.

Потери производительности от GIL зависят от характера программ и архитектуры системы. Большинство программ является однопоточными, либо запускает всего несколько потоков, из которых часть в каждый конкретный момент простаивает в ожидании. Персональные компьютеры обычно имеют небольшое количество процессорных ядер, которые загружены параллельно исполняющимися в системе процессами, так что реальные потери производительности на персональных компьютерах из-за GIL невелики. Но в серверных приложениях может быть удобно использовать десятки и сотни (а то и больше) параллельных потоков (например, в системах массового обслуживания, где каждый поток обрабатывает данные для отдельного пользовательского запроса), а серверы на конец 2010-х годов нередко имеют десятки и даже сотни процессорных ядер, то есть технически могут обеспечить этим потокам физически одновременное исполнение; в таких условиях GIL может приводить к действительно значительному снижению общей производительности, так как лишает программу возможности полноценно использовать ресурсы многоядерных систем.

Гвидо ван Россум говорил, что GIL «не так уж и плох» и он будет в CPython до тех пор, пока «кто-то другой» не представит реализацию Python без GIL, с которой бы однопоточные скрипты работали так же быстро[151][152].

В задачи разработки входит работа по оптимизации GIL[153]. Отказ от GIL в ближайшем будущем не планируется, так как альтернативные механизмы на однопоточных приложениях, которых большинство, работают медленнее или потребляют больше ресурсов:

Вариант интерпретатора с синхронизацией доступа к отдельным объектам вместо глобальной блокировки[154] из-за частых захватов/освобождений блокировок оказался слишком медленным.
python-safethread — CPython без GIL[155], по утверждениям авторов, обеспечивает на однопоточных приложениях скорость порядка 60-65 % от скорости CPython.
Реализация потоков через процессы ОС, например, модуль processing[156] (с версии 2.6 переименован в multiprocessing). В UNIX-подобных системах накладные расходы при порождении процесса невелики, но в Windows использование процессов вместо потоков ведёт к существенному увеличению расхода оперативной памяти.
Отказ от совместного использования изменяемых данных и вызовов внешнего кода. При этом данные дублируются в потоках и их синхронизация (если таковая нужна) лежит на программисте[157]. Этот подход также увеличивает потребление оперативной памяти, хотя и не настолько сильно, как при использовании процессов в Windows.
Библиотеки, обеспечивающие собственную организацию поддержки потоков, такие как parallelpython[158], pympi[159] и другие.
Радикальным вариантом решения проблемы может быть переход на Jython и IronPython, работающие на виртуальных машинах Java и .NET/Mono: эти реализации вообще не используют GIL.

Синтаксис и семантика
Несмотря на то, что одним из заявленных принципов дизайна Python является принцип наименьшего удивления, критики отмечают целый ряд архитектурных решений, которые могут вводить в заблуждение или вызывать недоумение у программистов, привыкших к другим распространённым языкам[160]. В их числе:

Отличие в принципе работы оператора присвоения по сравнению со статически-типизированными языками. В Python при присвоении значения копируется ссылка на объект, а не значение. При работе с простыми неизменяемыми типами возникает ощущение изменения значения переменной при присваивании ей значения, однако фактически присваивается ссылка на другое значение, например, при увеличении значения переменной типа int на 1 меняется ссылка, а не увеличивается значение по ссылке. Однако при работе с изменяемыми типами их содержимое можно менять по ссылке, поэтому при присвоении одной переменной ссылки на другую и последующем изменении значения в одной из двух переменных оно изменится в обоих переменных, что хорошо заметно при работе со списками[160][161]. При этом кортежи хоть и являются неизменяемыми, но могут хранить ссылки на изменяемые объекты, поэтому по факту кортежи тоже можно менять[162];
Отличие в поведении на некоторых типах «сокращённых» операторов, таких как += и их развёрнутой записи, хотя в большинстве языков «сокращённый» вариант — это просто краткая запись полного, и семантически они абсолютно эквивалентны. Пример с использованием x +=:
>>> x = [1, 2]
>>> y = x
>>> x += [3, 4]
>>> x
[1, 2, 3, 4]
>>> y
[1, 2, 3, 4]
Аналогичный пример с использованием x = x +:
>>> x = [1, 2]
>>> y = x
>>> x = x + [3, 4]
>>> x
[1, 2, 3, 4]
>>> y
[1, 2]
Жёсткая трактовка лексической области видимости, подобная используемой в JavaScript: даже если переменная получает значение в последней строке функции, её областью видимости является вся функция.
Путаница между полями класса и полями объекта: текущее значение поля класса инициализирует одноимённое поле объекта, но не при создании объекта, а при первой записи значения в данное поле.
class Colored:
    color = "red"

obj1 = Colored()
print(obj1.color)        # выводится исходное значение поля КЛАССА
Colored.color = "green"  # изменение поля КЛАССА
print(obj1.color)        # выводится значение поля КЛАССА
obj1.color = "blue"      # изменяется поле ОБЪЕКТА и фиксируется его значение
Colored.color = "yellow" # изменение поля КЛАССА, которое уже не отразится на объекте
print(obj1.color)        # выводится поле ОБЪЕКТА

# Скрипт выведет: 
red
green
blue
В примере выше три раза выводится поле color объекта obj1 класса Colored. При этом пока не выполнена запись в это поле, выводится текущее значение поля класса, и в третий раз — значение поля объекта. Такое сохранение связи между полем объекта и класса до первой перезаписи может стать причиной неожиданного эффекта: если в программе меняется значение поля класса, то все объекты, одноимённые поля которых ещё не перезаписаны, окажутся неявно изменены.
Интуитивно трудно предсказуемое поведение параметров со значением-объектом по умолчанию. Если в качестве инициализатора для параметра по умолчанию указать конструктор объекта, это приведёт к созданию статического объекта, ссылка на который и будет передаваться по умолчанию в каждый вызов[163]. Это может повлечь трудно уловимые ошибки.
Невозможность модификации встроенных классов
По сравнению с Ruby и некоторыми другими языками, в Python отсутствует возможность модифицировать встроенные классы, такие, как int, str, float, list и другие, что, однако, позволяет Python потреблять меньше оперативной памяти и быстрее работать. Ещё одной причиной введения такого ограничения является необходимость согласования с модулями расширения. Многие модули (в целях оптимизации быстродействия) преобразуют Python-объекты элементарных типов к соответствующим Си-типам вместо манипуляций с ними посредством Си-API. Также это избавляет от многих потенциальных ошибок при неконтролируемом динамическом переопределении встроенных типов.

Реализации
CPython
Основная статья: CPython
CPython является основной реализацией языка. Он написан на языке Си и является переносимым на разные платформы. В основе управления памятью лежит использование комбинации счётчиков ссылок и сборщика мусора, ответственного за поиск циклических захватов ссылок[40]. Хотя язык считается интерпретируемым, на самом деле он компилируется в промежуточный высокоуровневый байт-код[164][165], который затем исполняется через стековую виртуальную машину[40]. Например, вызов функции print() может быть представлен в следующем виде[165]:

  1           0 LOAD_NAME                0 (print)
              2 LOAD_CONST               0 ('Hello World!')
              4 CALL_FUNCTION            1
              6 RETURN_VALUE
Имена в языке имеют позднее связывание, в результате чего можно писать обращения к переменным, методам и атрибутам, которых ещё нет, но они должны быть объявлены на момент исполнения кода, использующего их. Каждый объект в Python имеет словарь, представленный хеш-таблицей, через который происходит сопоставление названий атрибутов их значениям. Глобальные переменные также сопоставляются через словарь. Одно обращение к методу или атрибуту может сопровождаться поочерёдным поиском в нескольких словарях[40].

PyPy
Основная статья: PyPy
PyPy — реализация Python, написанная на RPython (подмножество Python, имеющее намного меньше динамических возможностей). Позволяет легко проверять новые возможности. В PyPy, кроме стандартного CPython, включены возможности Stackless, Psyco, модификация AST «на лету» и многое другое. В проект интегрированы возможности анализа Python-кода и трансляция в другие языки и байткоды виртуальных машин (Си, LLVM, Javascript, .NET с версии 0.9.9). Начиная с 0.9.0, возможна полностью автоматическая трансляция RPython в Си, в результате чего достигается скорость, приемлемая для использования (в 2—3 раза ниже, чем CPython при отключённом JIT для версии 0.9.9). По умолчанию PyPy поставляется со встроенным JIT-компилятором, с помощью которого он способен работать намного быстрее, чем CPython.

Jython
Пазлинка и перо
Этот раздел статьи ещё не написан.
Согласно замыслу одного или нескольких участников Википедии, на этом месте должен располагаться специальный раздел.
Вы можете помочь проекту, написав этот раздел.
Основная статья: Jython
Jython — реализация Python, компилирующая код на Python в байт-код Java, который может быть выполнен JVM. Также может использоваться для импорта класса, исходный код которого был написан на Java в качестве модуля для Python[166].

Другие реализации
Существуют также другие реализации.

Numba[en] — Jit-компилятор на основе LLVM с поддержкой NumPy.
PyS60[167] — реализация языка для смартфонов фирмы Nokia на платформе Series 60.
IronPython — Python для .NET Framework и Mono. Компилирует Python программы в MSIL, таким образом предоставляя полную интеграцию с .NET-системой[168].
Stackless — также написанная на Си реализация Python. Это не полноценная реализация, а патчи к CPython. Предоставляет расширенные возможности многопоточного программирования и значительно большую глубину рекурсии.
Python for .NET[169] — ещё одна реализация Python для .NET. В отличие от IronPython эта реализация не компилирует Python код в MSIL, а только предоставляет интерпретатор, написанный на C#. Позволяет использовать .NET-сборки из Python кода.
Jython — реализация Python, использующая JVM в качестве среды исполнения. Позволяет прозрачно использовать Java-библиотеки.
python-safethread[155] — версия CPython без GIL, что позволяет одновременно исполнять Python потоки на всех доступных процессорах. Внесены также некоторые другие изменения.
Unladen Swallow — начатый Google проект по разработке высокоэффективного, максимально совместимого с CPython JIT-компилятора на базе LLVM. Согласно планам по развитию Python[170], планировалось перенести исходный код Unladen Swallow в CPython в версии 3.3. Но PEP-3146 был отменён в связи с отсутствием интереса к Unladen Swallow со стороны Google, основного спонсора разработки[171].
tinypy[172] — минималистическая версия Python. Часть возможностей CPython не реализована.
MicroPython — реализация Python 3 для встроенных систем с малым объёмом оперативной памяти[173].
Brython[174] — реализация языка на клиентском JavaScript, позволяющая писать браузерные скрипты на Python 3.
QPython[175] — реализация Python для Android. Проект всё ещё на стадии тестирования, однако на qpython уже портированы некоторые самые необходимые библиотеки. Позволяет и работать в интерактивном режиме. Существует также Qpython3.
Grumpy[176] — реализация Python на Go (в активной разработке), позволяющая работать коду на Python без виртуальной машины: скомпилировать код Python в код Go, а затем уже получить исполняемый файл.
Специализированные подмножества/расширения Python
На основе Python было создано несколько специализированных подмножеств языка, в основном предназначенных для статической компиляции в машинный код. Некоторые из них перечислены ниже.

RPython[177] — созданная в рамках проекта PyPy сильно ограниченная реализация Python без динамизма времени исполнения и некоторых других возможностей. Код на RPython можно компилировать во множество других языков/платформ — C, JavaScript, Lisp, .NET[178], LLVM. На RPython написан интерпретатор PyPy.
Pyrex[179] — ограниченная реализация Python, но несколько меньше, чем RPython. Pyrex расширен возможностями статической типизации типами из языка C и позволяет свободно смешивать типизированный и не типизированный код. Предназначен для написания модулей расширений, компилируется в код на языке C.
Cython[180] — расширенная версия Pyrex.
Проект Shedskin — предназначен для компиляции неявно статически типизированного кода на Python в оптимизированный код на языке C++.

Инструменты поддержки программирования
Интерактивный режим
Подобно Лиспу и Прологу, Python может использоваться в интерактивном режиме, при котором введённые с клавиатуры операторы сразу же выполняются, а результат выводится на экран (REPL). Этот режим удобен как при изучении языка, так и в процессе профессиональной разработки — для быстрого тестирования отдельных фрагментов кода, — так как обеспечивает немедленную обратную связь. Также он позволяет использовать интерпретатор в качестве калькулятора с большим набором функций.

Эталонная реализация Python имеет встроенный интерактивный интерпретатор, работающий в режиме текстового терминала и позволяющий выполнять все основные операции. В интерактивном режиме доступен отладчик pdb и система помощи (вызывается по help()), работающая для всех модулей, классов и функций, которые содержат строки документации:
>>> from math import * # импорт математических функций
>>> help(sorted) # помощь по функции sorted
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.
    . . .
IPython[181] — выходящая под BSD-лицензией кросс-платформенная интерактивная оболочка, предоставляющая расширенную интроспекцию и дополнительные команды. В частности, позволяет передавать исполняемому коду на Python результаты выполнения команд системной командной оболочки. Поддерживает подсветку кода и автоматическое дополнение.
bpython[182] — расширение стандартной командной оболочки Python с помощью ряда дополнительных модулей. Реализует подсветку синтаксиса, автоматическое дополнение кода с предложением вариантов, автоматическое выравнивание, интеграция с Pastebin, сохранение ввода в файл, восстановление удалённой строки, предложение параметров для функций.
Почти все IDE для Python поддерживают REPL для быстрого тестирования.

IDE

IDLE
Существует несколько специализированных IDE для разработки на Python.

Eric — полнофункциональный редактор Python и IDE, написанный на Python. Он базируется на кросс-платформенном фреймворке Qt, в качестве компонента редактирования используется QScintilla. Eric предоставляет возможности ведения проектов, отладки, профилирования, рефакторинга кода, взаимодействия с популярными системами управления версиями, такими как Subversion и Git. Расширяется через механизм плагинов. Репозиторий плагинов доступен прямо из среды разработки. Распространяется бесплатно, лицензия GNU GPL v3.
PyCharm — полнофункциональная IDE для Python от JetBrains, доступна на платформах Windows, macOS и Linux, существует в бесплатном (Community) и платном (Professional) вариантах.
Wing IDE  (англ.)рус. — линейка Python-IDE от американской фирмы Wingware, включает три варианта: «Wing 101», «Wing Personal», «Wing Pro», из которых первые два бесплатны, последний — платный. Версия Pro обладает всеми необходимыми средствами для профессиональной разработки, включая поддержку проектов, работу с системами управления версиями, расширенные возможности навигации по коду и анализа кода, рефакторинг, поддержка использования Django. Бесплатные версии предоставляют меньше функций и не выходят за пределы возможностей, доступных в других бесплатных IDE для Python.
Spyder — open-source IDE для Python под лицензией MIT, бесплатная, доступна на платформах Windows, Mac OS X и Linux. Особенностью является то, что IDE ориентирована на data science, в ней удобно работать с библиотеками типа SciPy, NumPy, Matplotlib. Spyder поставляется в комплекте с менеджером пакетов Anaconda. В целом обладает качествами стандартной IDE, имеет редактор с подсветкой синтаксиса, автоматическое дополнение кода, обозреватель документации.
Thonny — многоплатформенная бесплатная IDE, выпускается под лицензией MIT, поддерживается Институтом информатики Тартуского университета в Эстонии. Позиционируется как «Python IDE для новичков», полностью, включая интерпретатор Python, ставится «из коробки» пользователем без административных прав, сразу после установки может использоваться без дополнительных настроек. Предназначена для обучения, имеет улучшенную визуализацию порядка вычисления выражений и вызова функций, динамическую подсветку синтаксических ошибок, простой менеджер пакетов. Для профессионального применения возможностей недостаточно, например, нет поддержки проектов и интеграции с системами управления версиями.
Помимо этого, существуют плагины для поддержки программирования на Python для универсальных IDE Eclipse, KDevelop и Microsoft Visual Studio, а также имеется поддержка подсветки синтаксиса, автодополнения кода и подключения средств отладки и запуска приложений для целого ряда распространённых текстовых редакторов.

Применение

Python Powered
Python — стабильный и распространённый язык. Он используется во многих проектах и в различных качествах: как основной язык программирования или для создания расширений и интеграции приложений. На Python реализовано большое количество проектов, также он активно используется для создания прототипов будущих программ.

Python является лёгким в изучении языком, и часто изучается как первый язык[25], в том числе используется при обучении детей программированию[183]. Как первый язык он хорошо подходит, поскольку программы на нём близки к естественному языку, на котором люди привыкли думать, а для написания корректной программы требуется минимальное количество ключевых слов. В других же языках, таких как C++, существует большое количество различных синтаксических конструкций и элементов языка, которым приходится уделять внимание вместо изучения алгоритмов[132].

Являясь приложением с открытым исходным кодом, интерпретатор Python используется по всему миру и поставляется в составе операционных систем на базе Linux, а также в компьютерах от фирмы Apple. Python популярен среди индивидуальных разработчиков, но также используется крупными компаниями в достаточно серьёзных продуктах, ориентированных на получение прибыли[184]. На Python написан Reddit[44]. В Dropbox также активно применяется Python, а из-за сложностей динамической типизации и огромного количества кода компания перешла к статической типизации с помощью открытого проекта Mypy[185] Также Python активно используется в Facebook[186] и Instagram[187]. Многие компании используют Python для тестирования аппаратного обеспечения, среди этих компаний значатся Intel, Cisco, Hewlett-Packard и IBM. Industrial Light & Magic и Pixar используют его при создании анимационных фильмов[184].

Язык активно используется компанией Google в её поисковой системе, а Youtube в значительной степени написан с использованием Python[188][184]. Кроме того, Google спонсирует разработку Python с 2010 года[189][190], и поддержку PyPI, основной системы распространения пакетов для Python[189][191].

Сильными сторонами Python являются его модульность и возможность интегрироваться с другими языками программирования, в том числе в составе сложных комплексных приложений и систем[192]. Сочетание простоты и лаконичности с большим количеством возможностей делает Python удобным в качестве скриптового языка[источник не указан 444 дня]. Многие проекты предоставляют прикладной интерфейс программирования на Python для написания скриптов, например, среды 3D-моделирования Autodesk Maya[184], Blender[193] и Houdini[194], а также свободная геоинформационная система QGIS[195]. Некоторые проекты реализуют базовую часть на более производительных языках программирования, а для упрощения работы предоставляют полноценный интерфейс прикладного программирования на Python[источник не указан 444 дня]. Так, движок свободного видеоредактора OpenShot реализован в виде библиотеки libopenshot, написанной на C++ с использованием библиотек на Си, а все возможности полностью покрыты прикладным интерфейсом программирования Python[196][значимость факта?]. Агентство национальной безопасности США использует Python для анализа данных, а NASA использует его при выполнении научных задач[184]. Из инструментов, используемых в NASA, можно отметить свободный графический симулятор сети GNS3[en], который также хорошо зарекомендовал себя в корпоративной среде и используется в технологических компаниях, например, в Intel[197]. На Python написана также свободная популярная программа нарезки 3D моделей для печати на 3D-принтерах Cura[198][199].

Python с пакетами NumPy, SciPy и MatPlotLib активно используется как универсальная среда для научных расчётов в качестве замены распространённым специализированным коммерческим пакетам, таким как Matlab, предоставляя аналогичную функциональность и более низкий порог вхождения[200]. По большей части на Python написана также графическая программа Veusz  (англ.)рус.[201], позволяющая создавать качественные графики, готовые для размещения в научных публикациях[202][значимость факта?]. Библиотека Astropy — популярный инструмент для астрономических расчётов[203][значимость факта?].

Также Python подходит для выполнения нестандартных или сложных задач в системах сборки проектов, что обусловлено отсутствием необходимости предварительной компиляции исходных файлов. В проекте Google Test он используется для генерации исходного кода mock-объектов для классов языка C++[204][значимость факта?].

Интерпретатор Python может использоваться в качестве мощной командной оболочки и скриптового языка для написания командных файлов ОС. Лёгкость обращения из Python-скриптов к внешним программам и наличие библиотек, дающих доступ к управлению системой, делают Python удобным инструментом для системного администрирования[205]. Он широко используется для этой цели на платформе Linux: обычно Python поставляется с системой, во многих дистрибутивах инсталляторы и визуальный интерфейс системных утилит написаны именно на Python. Используется он и в администрировании других Unix-систем, в частности, в Solaris и macOS[205]. Кроссплатформенность самого языка и библиотек делает его привлекательным для унифицированной автоматизации задач системного администрирования в гетерогенных средах, где совместно применяются компьютеры с операционными системами различных типов.

Будучи языком общего назначения Python применим почти во всех сферах деятельности. Фактически Python используется практически любой солидной компанией тем или иным образом как для выполнения текущих задач, так и в тестировании, администрировании или в разработке программных продуктов[184].

См. также
Сравнение интегрированных средств разработки (IDE)
Примечания
Комментарии
Недоступно непосредственно по имени типа.
Значение в секундах можно получить с помощью команды sys.getswitchinterval()[149] и изменить во время работы программы с помощью sys.setswitchinterval()[150]
Источники
Показывать компактно
https://docs.python.org/3/license.html
Python 3.10.5 is available (англ.) — 2022.
Why was Python created in the first place?. General Python FAQ. Python Software Foundation. Дата обращения: 22 марта 2007. Архивировано 24 октября 2012 года.
Ada 83 Reference Manual (raise statement). Дата обращения: 7 января 2020. Архивировано 22 октября 2019 года.
Kuchling, Andrew M. Interview with Guido van Rossum (July 1998). amk.ca (22 December 2006). Дата обращения: 12 марта 2012. Архивировано 1 мая 2007 года.
itertools — Functions creating iterators for efficient looping — Python 3.7.1 documentation. docs.python.org. Дата обращения: 22 ноября 2016. Архивировано 14 июня 2020 года.
van Rossum, Guido (1993). “An Introduction to Python for UNIX/C Programmers”. Proceedings of the NLUUG Najaarsconferentie (Dutch UNIX Users Group). CiteSeerX 10.1.1.38.2023. even though the design of C is far from ideal, its influence on Python is considerable.
Classes. The Python Tutorial. Python Software Foundation. — «It is a mixture of the class mechanisms found in C++ and Modula-3». Дата обращения: 20 февраля 2012. Архивировано 23 октября 2012 года.
Lundh, Fredrik Call By Object. effbot.org. — «replace "CLU" with "Python", "record" with "instance", and "procedure" with "function or method", and you get a pretty accurate description of Python's object model.». Дата обращения: 21 ноября 2017. Архивировано 23 ноября 2019 года.
Simionato, Michele The Python 2.3 Method Resolution Order. Python Software Foundation. — «The C3 method itself has nothing to do with Python, since it was invented by people working on Dylan and it is described in a paper intended for lispers». Дата обращения: 29 июля 2014. Архивировано 20 августа 2020 года.
Kuchling, A. M. Functional Programming HOWTO. Python v2.7.2 documentation. Python Software Foundation. Дата обращения: 9 февраля 2012. Архивировано 24 октября 2012 года.
Schemenauer, Neil; Peters, Tim; Hetland, Magnus Lie PEP 255 – Simple Generators. Python Enhancement Proposals. Python Software Foundation (18 May 2001). Дата обращения: 9 февраля 2012. Архивировано 5 июня 2020 года.
Smith, Kevin D.; Jewett, Jim J.; Montanaro, Skip; Baxter, Anthony PEP 318 – Decorators for Functions and Methods. Python Enhancement Proposals. Python Software Foundation (2 September 2004). Дата обращения: 24 февраля 2012. Архивировано 3 июня 2020 года.
More Control Flow Tools. Python 3 documentation. Python Software Foundation. Дата обращения: 24 июля 2015. Архивировано 4 июня 2016 года.
Historique et licence
https://docs.python.org/3/library/py_compile.html
https://docs.python.org/3/faq/windows.html#is-a-pyd-file-the-same-as-a-dll
https://www.python.org/dev/peps/pep-0488/
https://docs.python.org/3/using/windows.html
https://docs.python.org/3/library/zipapp.html
https://www.python.org/dev/peps/pep-0484/
https://www.python.org/downloads/
Мария «Mifrill» Нефедова, Создатели языков программирования: Они такие разные, но кодинг их объединяет, Хакер № 09/08 (117). Дата обращения: 1 декабря 2012. Архивировано 2 июля 2013 года.
Прохоренок Н., Дронов В. Введение // Python 3. Самое необходимое, 2-е изд.. — БХВ-Петербург, 2019. — С. 11. — 608 с. — ISBN 9785977539944.
Yogesh Rana. Python: Simple though an Important Programming language (англ.) // International Research Journal of Engineering and Technology (IRJET). — 2019. — 2 February (vol. 06, iss. 2). — P. 1856—1858. — ISSN 2395-0056. Архивировано 11 февраля 2021 года.
SkipMontanaro. Why is Python a dynamic language and also a strongly typed language - Python Wiki (англ.). wiki.python.org (24 февраля 2012). Дата обращения: 14 марта 2021. Архивировано 14 марта 2021 года.
Mark Lutz. A Python Q&A Session (англ.). Learning Python, 3rd Edition [Book]. O'Reilly Media, Inc. (2007). Дата обращения: 11 февраля 2021. Архивировано 8 февраля 2021 года.
Python Introduction | (англ.). Python Education. Google Developers (20 августа 2018). Дата обращения: 21 февраля 2021. Архивировано 4 декабря 2020 года.
Satwik Kansal. Metaprogramming in Python (англ.). IBM (5 апреля 2018). Дата обращения: 14 апреля 2021. Архивировано 27 февраля 2021 года.
Alexandre Bergel, Lorenzo Bettini. Generic Programming in Pharo (англ.) // Software and Data Technologies / José Cordeiro, Slimane Hammoudi, Marten van Sinderen. — Berlin, Heidelberg: Springer, 2013. — P. 66–79. — ISBN 978-3-642-45404-2. — doi:10.1007/978-3-642-45404-2_5. Архивировано 13 февраля 2021 года.
R. Peschke, K. Nishimura, G. Varner. ARGG-HDL: A High Level Python BasedObject-Oriented HDL Framework (англ.) // IEEE Transactions on Nuclear Science : pre-print. — 2020. — October. — arXiv:011.02626v1. Архивировано 7 ноября 2020 года.
Steven F. Lott. Aspect-oriented programming (англ.). Mastering Object-Oriented Python - Second Edition. Packt Publishing (2019). Дата обращения: 21 февраля 2021. Архивировано 21 февраля 2021 года.
Arne Bachmann, Henning Bergmeyer, Andreas Schreiber. Evaluation of aspect-oriented frameworks in Python for extending a project with provenance documentation features (англ.) // The Python Papers. — 2011. — Vol. 6, iss. 3. — P. 1–18. — ISSN 1834-3147. Архивировано 22 апреля 2018 года.
Steven Cooper. Data Science from Scratch: The #1 Data Science Guide for Everything A Data Scientist Needs to Know: Python, Linear Algebra, Statistics, Coding, Applications, Neural Networks, and Decision Trees. — Roland Bind, 2018. — 126 с. Архивная копия от 21 февраля 2021 на Wayback Machine
Reuven M. Lerner. Multiprocessing in Python (англ.). Linux Journal (16 апреля 2018). Дата обращения: 14 февраля 2021. Архивировано 14 февраля 2021 года.
David Beazley, Brian K. Jones. 10. Modules and Packages - Python Cookbook, 3rd Edition [Book] (англ.). Python Cookbook, 3rd Edition. O'Reilly Media, Inc. (2013). Дата обращения: 21 февраля 2021. Архивировано 21 февраля 2021 года.
About Python. Дата обращения: 7 августа 2007. Архивировано 11 августа 2007 года.
PythonImplementations - Python Wiki (англ.). wiki.python.org (21 июля 2020). Дата обращения: 17 февраля 2021. Архивировано 11 ноября 2020 года.
History and License (англ.). Python. Дата обращения: 21 мая 2021. Архивировано 5 декабря 2016 года.
Mostafa Chandra Krintz, C. Cascaval, D. Edelsohn, P. Nagpurkar, P. Wu. Understanding the Potential of Interpreter-based Optimizations for Python (англ.) // UCSB Technical Report. — 2010. — 11 August. Архивировано 23 февраля 2021 года.
J. Akeret, L. Gamper, A. Amara, A. Refregier. HOPE: A Python just-in-time compiler for astrophysical computations (англ.) // Astronomy and Computing. — 2015. — 1 April (vol. 10). — P. 1–8. — ISSN 2213-1337. — doi:10.1016/j.ascom.2014.12.001. — arXiv:1410.4345v2. Архивировано 15 февраля 2021 года.
PEP 373 -- Python 2.7 Release Schedule (англ.) (23 марта 2014). Дата обращения: 7 марта 2021. Архивировано 25 февраля 2021 года.
Berk Ekmekci, Charles E. McAnany, Cameron Mura. An Introduction to Programming for Bioscientists: A Python-Based Primer (англ.) // PLOS Computational Biology. — 2016. — 6 July (vol. 12, iss. 6). — P. e1004867. — ISSN 1553-7358. — doi:10.1371/journal.pcbi.1004867. — PMID 27271528. Архивировано 16 февраля 2021 года.
Kalyani Adawadkar. Python Programming - Applications and Future (англ.) // International Journal of Advance Engineering and Research Development. — 2017. — April (iss. SIEICON-2017). — P. 1—4. — ISSN 2348-447. Архивировано 15 июля 2020 года.
Ethan Bommarito, Michael James Bommarito. An Empirical Analysis of the Python Package Index (PyPI) (англ.) // Social Science Research Network. — Rochester, NY: Social Science Research Network, 2019. — 25 July. — doi:10.2139/ssrn.3426281. — arXiv:arXiv:1907.11073v2. Архивировано 9 июня 2021 года.
Pratik Desai. Python Programming for Arduino. — Packt Publishing Ltd, 2015. — С. 8. — 400 с. — ISBN 978-1-78328-594-5. Архивная копия от 21 февраля 2021 на Wayback Machine
Sebastian Bassi. A Primer on Python for Life Science Researchers (англ.) // PLOS Computational Biology. — 2007. — 30 November (vol. 3, iss. 11). — P. e199. — ISSN 1553-7358. — doi:10.1371/journal.pcbi.0030199. Архивировано 13 марта 2021 года.
TIOBE Index (англ.). tiobe.com. TIOBE - The Software Quality Company. Дата обращения: 12 октября 2021. Архивировано 12 октября 2021 года.
Python | TIOBE - The Software Quality Company. www.tiobe.com. Дата обращения: 13 февраля 2021. Архивировано 6 февраля 2021 года.
Архивированная копия (недоступная ссылка). Дата обращения: 1 июня 2009. Архивировано 17 февраля 2016 года.
General Python FAQ. Python v2.7.3 documentation. Docs.python.org. Дата обращения: 4 июня 2020. Архивировано 24 октября 2012 года.
Index of Python Enhancement Proposals (PEPs). Дата обращения: 28 января 2007. Архивировано 28 января 2007 года.
Python 3.0 Release. Дата обращения: 1 июня 2009. Архивировано 2 июня 2009 года.
PEP 373 -- Python 2.7 Release Schedule. python.org. Дата обращения: 9 января 2017. Архивировано 19 мая 2020 года.
PEP 466 -- Network Security Enhancements for Python 2.7.x. python.org. Дата обращения: 9 января 2017. Архивировано 4 июня 2020 года.
Sunsetting Python 2 (англ.). Python.org. Дата обращения: 22 сентября 2019. Архивировано 12 января 2020 года.
Python Developer's Guide — Python Developer's Guide. devguide.python.org. Дата обращения: 17 декабря 2019. Архивировано 9 ноября 2020 года.
Extending and Embedding the Python Interpreter: Reference Counts (англ.). Docs.python.org. — «Since Python makes heavy use of malloc() and free(), it needs a strategy to avoid memory leaks as well as the use of freed memory. The chosen method is called reference counting.». Дата обращения: 5 июня 2020. Архивировано 18 октября 2012 года.
Hettinger, Raymond PEP 289 – Generator Expressions. Python Enhancement Proposals. Python Software Foundation (30 January 2002). Дата обращения: 19 февраля 2012. Архивировано 14 июня 2020 года.
6.5 itertools – Functions creating iterators for efficient looping. Docs.python.org. Дата обращения: 22 ноября 2016. Архивировано 14 июня 2020 года.
PEP 20 — The Zen of Python. Дата обращения: 23 сентября 2005. Архивировано 17 июля 2005 года.
Бейдер Дэн. Чистый Python. Тонкости программирования для профи. — "Издательский дом ""Питер""", 2018. — С. 64—65. — 288 с. — ISBN 978-5-4461-0803-9. Архивная копия от 10 апреля 2021 на Wayback Machine
Venners, Bill The Making of Python. Artima Developer. Artima (13 January 2003). Дата обращения: 22 марта 2007. Архивировано 1 сентября 2016 года.
Peters, Tim PEP 20 – The Zen of Python. Python Enhancement Proposals. Python Software Foundation (19 August 2004). Дата обращения: 24 ноября 2008. Архивировано 26 декабря 2018 года.
Alex Martelli, Anna Ravenscroft, David Ascher. Python Cookbook, 2nd Edition. — O'Reilly Media, 2005. — P. 230. — ISBN 978-0-596-00797-3. Архивная копия от 23 февраля 2020 на Wayback Machine
Python Culture (недоступная ссылка). ebeab (January 21, 2014). Архивировано 30 января 2014 года.
Mark Summerfield. Python in Practice: Create Better Programs Using Concurrency, Libraries, and Patterns. — Addison-Wesley, 2013-08-20. — С. 201. — 326 с. — ISBN 978-0-13-337323-3. Архивная копия от 9 июня 2021 на Wayback Machine
15 Ways Python Is a Powerful Force on the Web (недоступная ссылка). Дата обращения: 28 декабря 2020. Архивировано 11 мая 2019 года.
8.18. pprint — Data pretty printer — Python 3.8.3 documentation. docs.python.org. Дата обращения: 28 декабря 2020. Архивировано 22 января 2021 года.
Python on Android (англ.) (недоступная ссылка). www.damonkohler.com. Дата обращения: 19 декабря 2009. Архивировано 28 января 2011 года.
Port-Specific Changes: Windows (англ.) (недоступная ссылка). Python v2.6.1 documentation. What’s New in Python 2.6. Python Software Foundation. Дата обращения: 11 декабря 2008. Архивировано 28 января 2011 года.
3. Using Python on Windows — Python 3.5.9 documentation (англ.). Python Documentation. Python Software Foundation. Дата обращения: 8 июня 2020. Архивировано 15 октября 2020 года.
Drop support of Windows Vista and 7 in Python 3.9 (англ.). Дата обращения: 10 января 2021. Архивировано 4 ноября 2020 года.
Рамальо, 2016, p. 61.
15. Floating Point Arithmetic: Issues and Limitations — Python 3.8.3 documentation. docs.python.org. — «Almost all machines today (November 2000) use IEEE-754 floating point arithmetic, and almost all platforms map Python floats to IEEE-754 “double precision”.». Дата обращения: 6 июня 2020. Архивировано 6 июня 2020 года.
Moshe Zadka, Guido van Rossum. PEP 237 – Unifying Long Integers and Integers. Python Enhancement Proposals. Python Software Foundation (11 March 2001). Дата обращения: 24 сентября 2011. Архивировано 28 мая 2020 года.
Built-in Types. Дата обращения: 3 октября 2019. Архивировано 14 июня 2020 года.
Рамальо, 2016, pp. 52—54.
Fredrik Lundh. Call By Object (англ.) (недоступная ссылка). effbot.org. Дата обращения: 31 мая 2014. Архивировано 23 ноября 2019 года.
Foreword for «Programming Python» (1st ed.) (англ.). Дата обращения: 7 марта 2021. Архивировано 20 января 2021 года.
2.3.2. Reserved classes of identifiers. Python documentation (18 октября 2009). Архивировано 28 января 2011 года.
…целостность больших проектов на Python строится на двух вещах: тесты и doc-строка. Дата обращения: 31 октября 2008. Архивировано 21 октября 2008 года.
Steve D. Jost. Structured Programming Details. IT 211, DePaul University (2019). Дата обращения: 17 февраля 2021. Архивировано 29 апреля 2020 года.
PyDBC: method preconditions, method postconditions and class invariants for Python. Дата обращения: 24 сентября 2011. Архивировано 23 ноября 2019 года.
Contracts for Python. Дата обращения: 24 сентября 2011. Архивировано 15 июня 2020 года.
PyDatalog. Дата обращения: 22 июля 2012. Архивировано 13 июня 2020 года.
Object-oriented programming in Python (англ.). IBM Developer. ibm.com (20 октября 2020). Дата обращения: 11 марта 2021. Архивировано 11 марта 2021 года.
9. Classes (англ.). Python 3.9.2 documentation. docs.python.org. Дата обращения: 14 марта 2021. Архивировано 14 марта 2021 года.
Fawzi Albalooshi, Amjad Mahmood. A Comparative Study on the Effect of Multiple Inheritance Mechanism in Java, C++, and Python on Complexity and Reusability of Code (англ.) // International Journal of Advanced Computer Science and Applications (IJACSA). — 2017. — Vol. 8, iss. 6. — ISSN 2156-5570. — doi:10.14569/IJACSA.2017.080614. Архивировано 10 июля 2020 года.
Michele Simionato. The Python 2.3 Method Resolution Order (англ.). Python.org. Дата обращения: 14 марта 2021. Архивировано 14 марта 2021 года.
PEP 484 -- Type Hints (англ.). Python.org (24 сентября 2014). Дата обращения: 13 февраля 2021. Архивировано 9 февраля 2021 года.
Jukka Lehtosalo. Generics (англ.). Mypy 0.800 documentation. Read the Docs (2016). Дата обращения: 13 февраля 2021. Архивировано 13 февраля 2021 года.
Рамальо, 2016, pp. 188—191.
David Mertz. Functional Programming in Python. — O'Reilly, 2015. — ISBN 978-1491928561.
Рамальо, 2016, p. 273.
Рамальо, 2016, pp. 613—708.
Патрик О'Брайен. Руководство по интроспекции на Python / Intersoft Lab.
Beazley, 2009, pp. 222—225.
Рамальо, 2016, pp. 214—246.
Рамальо, 2016, pp. 686—688.
6.2. re — Regular expression operations — Python 3.5.1 documentation. Дата обращения: 11 мая 2016. Архивировано 18 июля 2018 года.
A.M. Kuchling. PEP 206 -- Python Advanced Library, Python.org (14.07.2000). Архивировано 5 мая 2021 года. Дата обращения 4 апреля 2021.
eGenix.com — Professional Python Software, Skills and Services. Дата обращения: 29 января 2007. Архивировано 28 января 2007 года.
numarray Home Page. Дата обращения: 5 февраля 2007. Архивировано 9 июня 2021 года.
PEP333. Дата обращения: 29 января 2007. Архивировано 9 июня 2021 года.
Pyste Documentation (недоступная ссылка). Дата обращения: 3 февраля 2007. Архивировано 3 февраля 2007 года.
Архивированная копия (недоступная ссылка). Дата обращения: 3 февраля 2007. Архивировано 8 февраля 2007 года.
Архивированная копия. Дата обращения: 3 февраля 2007. Архивировано 8 февраля 2007 года.
Boost.Python. Дата обращения: 3 февраля 2007. Архивировано 3 февраля 2007 года.
http://www.drdobbs.com/building-hybrid-systems-with-boostpython/184401666 Архивная копия от 13 октября 2015 на Wayback Machine Building Hybrid Systems with Boost.Python
PyCXX: Write Python Extensions in C. Дата обращения: 3 февраля 2007. Архивировано 3 февраля 2007 года.
Мост между C++ и Python. Дата обращения: 15 мая 2014. Архивировано 18 декабря 2014 года.
PyInline: Mix Other Languages directly Inline with your Python. Дата обращения: 3 февраля 2007. Архивировано 15 января 2007 года.
Weave (недоступная ссылка). Дата обращения: 3 февраля 2007. Архивировано 1 марта 2007 года.
wxPython. Дата обращения: 30 сентября 2008. Архивировано 9 июня 2021 года.
The GTK Team. The GTK Project - A free and open-source cross-platform widget toolkit (англ.). The GTK Team (5 июня 2015). Дата обращения: 25 января 2021. Архивировано 27 ноября 2020 года.
PyOpenGL — The Python OpenGL Binding. Дата обращения: 9 февраля 2007. Архивировано 15 июня 2011 года.
PyOgre : Ogre Wiki (недоступная ссылка). Дата обращения: 9 февраля 2007. Архивировано 6 февраля 2007 года.
pythonOCC, 3D CAD/CAE/PLM development framework for the Python programming language. Дата обращения: 28 марта 2009. Архивировано 8 августа 2011 года.
Open CASCADE Technology, 3D modeling & numerical simulation. Дата обращения: 28 марта 2009. Архивировано 18 марта 2009 года.
Typechecking module for Python (недоступная ссылка). Дата обращения: 10 февраля 2007. Архивировано 4 февраля 2007 года.
Method signature checking decorators " Python recipes " ActiveState Code. Дата обращения: 16 февраля 2008. Архивировано 13 февраля 2008 года.
PEP-3107. Дата обращения: 16 февраля 2007. Архивировано 8 мая 2007 года.
FrontPage — The PEAK Developers' Center. Дата обращения: 19 марта 2008. Архивировано 12 мая 2008 года.
PEAK-Rules. Дата обращения: 19 марта 2008. Архивировано 23 июля 2008 года.
PEP-3124. Дата обращения: 25 мая 2007. Архивировано 3 июля 2007 года.
overloading-lib Архивная копия от 17 сентября 2013 на Wayback Machine, Библиотека динамической перегрузки функций и методов основанной на типах аргументов для языка python
PyChecker: a python source code checking tool. Дата обращения: 3 февраля 2007. Архивировано 2 февраля 2007 года.
pylint (analyzes Python source code looking for bugs and signs of poor quality.) (Logilab.org). Дата обращения: 3 февраля 2007. Архивировано 12 февраля 2007 года.
Pylint 1.0.0 documentation, Introduction. Дата обращения: 23 ноября 2013. Архивировано 2 декабря 2013 года.
Mathieu Fourment, Michael R. Gillings. A comparison of common programming languages used in bioinformatics (англ.) // BMC Bioinformatics. — 2008. — 5 February (vol. 9, iss. 1). — P. 82. — ISSN 1471-2105. — doi:10.1186/1471-2105-9-82. Архивировано 19 марта 2021 года.
A Bogdanchikov, M Zhaparov, R Suliyev. Python to learn programming (англ.) // Journal of Physics: Conference Series. — 2013-04-10. — 10 April (vol. 423). — P. 012027. — ISSN 1742-6596 1742-6588, 1742-6596. — doi:10.1088/1742-6596/423/1/012027. Архивировано 9 июня 2021 года.
Pascal Fua, Krzysztof Lis. Comparing Python, Go, and C++ on the N-Queens Problem // Computer Vision Laboratory, EPFL. — 2020. Архивировано 12 марта 2020 года.
Guido van Rossum. Comparing Python to Other Languages (англ.). Python.org (1997). Дата обращения: 16 марта 2021. Архивировано 16 марта 2021 года.
Muhammad Shoaib Farooq, Sher Afzal Khan, Farooq Ahmad, Saeed Islam, Adnan Abid. An Evaluation Framework and Comparative Analysis of the Widely Used First Programming Languages (англ.) // PLoS ONE. — 2014. — 24 February (vol. 9, iss. 2). — ISSN 1932-6203. — doi:10.1371/journal.pone.0088941. — PMID 24586449. Архивировано 15 марта 2021 года.
Kincaid, Jason. Google's Go: A New Programming Language That's Python Meets C++, TechCrunch (10 November 2009). Архивировано 18 января 2010 года. Дата обращения 16 февраля 2021.
Ceyhun Ozgur, Taylor Colliau, Grace Rogers, Zachariah Hughes, Elyse “Bennie” Myer-Tyson. MatLab vs. Python vs. R (англ.) // Journal of Data Science. — 2017. — Vol. 15. — P. 355—372. — ISSN 1680-743X. Архивировано 11 апреля 2021 года.
Alex MacCaw. The Little Book on CoffeeScript. — O'Reilly, 2012. — ISBN 9781449321055.
Proposals: iterators and generators [ES4 Wiki] (недоступная ссылка). wiki.ecmascript.org. Дата обращения: 24 ноября 2008. Архивировано 20 октября 2007 года.
Strachan, James Groovy – the birth of a new dynamic language for the Java platform (недоступная ссылка) (29 August 2003). Дата обращения: 11 июня 2007. Архивировано 5 апреля 2007 года.
Why We Created Julia. Julia website (February 2012). — «We want something as usable for general programming as Python [...]». Дата обращения: 5 июня 2014. Архивировано 2 мая 2020 года.
Yegulalp, Serdar Nim language draws from best of Python, Rust, Go, and Lisp. InfoWorld (16 January 2017). — «Nim's syntax is strongly reminiscent of Python's, as it uses indented code blocks and some of the same syntax (such as the way if/elif/then/else blocks are constructed).». Дата обращения: 16 февраля 2021. Архивировано 13 октября 2018 года.
An Interview with the Creator of Ruby. Linuxdevcenter.com. Дата обращения: 3 декабря 2012. Архивировано 28 апреля 2018 года.
Lattner, Chris Chris Lattner's Homepage. Chris Lattner (3 June 2014). — «I started work on the Swift Programming Language in July of 2010. I implemented much of the basic language structure, with only a few people knowing of its existence. A few other (amazing) people started contributing in earnest late in 2011, and it became a major focus for the Apple Developer Tools group in July 2013 [...] drawing ideas from Objective-C, Rust, Haskell, Ruby, Python, C#, CLU, and far too many others to list.». Дата обращения: 3 июня 2014. Архивировано 22 декабря 2015 года.
Python / C++ GNU g++ (недоступная ссылка). Computer Language Benchmarks Game.  ???. Дата обращения: 1 июля 2009. Архивировано 28 января 2011 года.
unladen-swallow. A faster implementation of Python (недоступная ссылка). code.google. — «Goals: … Produce a version of Python at least 5x faster than CPython». Дата обращения: 22 июня 2009. Архивировано 28 января 2011 года.
Яворски, Зиаде, 2021, p. 466.
Palach, 2014, pp. 16—17.
sys#sys.getswitchinterval(). Документация Python. Дата обращения: 25 октября 2021. Архивировано 25 октября 2021 года.
sys#sys.setswitchinterval(). Документация Python. Дата обращения: 25 октября 2021. Архивировано 25 октября 2021 года.
Guido van Rossum. the future of the GIL. Python Mailing Lists (8 мая 2007). Дата обращения: 3 марта 2021. Архивировано 9 ноября 2020 года.
Guido van Rossum. It isn't Easy to Remove the GIL. artima.com (10 сентября 2007). Дата обращения: 3 марта 2021. Архивировано 6 июня 2019 года.
Python-Dev] Reworking the GIL. Дата обращения: 7 декабря 2010. Архивировано 10 июня 2011 года.
Python 3000 FAQ. Дата обращения: 8 августа 2007. Архивировано 9 ноября 2020 года.
python-safethread — Project Hosting on Google Code. Дата обращения: 21 августа 2008. Архивировано 1 августа 2008 года.
Python Package Index : processing 0.52. Дата обращения: 8 августа 2007. Архивировано 13 октября 2007 года.
perlthrtut — perldoc.perl.org. Дата обращения: 10 апреля 2008. Архивировано 22 мая 2008 года.
Parallel Python — Home (недоступная ссылка). Дата обращения: 8 августа 2007. Архивировано 28 мая 2010 года.
pyMPI.sourceforge.net: Putting the py in MPI. Дата обращения: 8 августа 2007. Архивировано 18 октября 2007 года.
zephyrfalcon.org :: labs :: 10 Python pitfalls
Reeta Sahoo, Gagan Sahoo. Computer Science with Python. — New Delhi: New Saraswati House India Pvt Ltd, 2016. — С. 3.35—3.36. — 458 с. — ISBN 978-93-5199-980-5. Архивная копия от 22 января 2021 на Wayback Machine
Luciano Ramalho. Python tuples: immutable but potentially changing - O'Reilly Radar (англ.). radar.oreilly.com. O'Reilly (15 октября 2014). Дата обращения: 16 января 2021. Архивировано 16 января 2021 года.
8. Compound statements — Python 3.7.2 documentation. docs.python.org. Дата обращения: 5 февраля 2019. Архивировано 27 ноября 2019 года.
Obi Ike-Nwosu. Read Inside The Python Virtual Machine | Leanpub. Inside The Python Virtual Machine. leanpub.com. Дата обращения: 23 марта 2021. Архивировано 29 января 2021 года.
Получено с помощью dis.dis('print("Hello World!")').
К. Рейт, Т. Шлюссер, 2017, p. 23.
Python for S60 — OpenSource Архивировано 6 августа 2009 года.
IronPython. Дата обращения: 24 июля 2007. Архивировано 18 августа 2006 года.
Python for .NET. Дата обращения: 10 февраля 2007. Архивировано 16 февраля 2007 года.
PEP 3146 — Merging Unladen Swallow into CPython. Дата обращения: 8 июня 2010. Архивировано 3 июня 2010 года.
QINSB is not a Software Blog: Unladen Swallow Retrospective. Дата обращения: 19 мая 2012. Архивировано 22 марта 2012 года.
tinypy. Дата обращения: 21 августа 2008. Архивировано 18 сентября 2008 года.
MicroPython. Дата обращения: 4 июня 2014. Архивировано 6 июня 2014 года.
Сайт проекта Brython. Дата обращения: 6 ноября 2014. Архивировано 20 октября 2014 года.
Сайт проекта QPython. Дата обращения: 3 февраля 2015. Архивировано 4 февраля 2015 года.
Сайт проекта Grumpy. Дата обращения: 17 февраля 2021. Архивировано 9 ноября 2020 года.
PyPy[coding-guide] (недоступная ссылка). Дата обращения: 24 июля 2007. Архивировано 7 июля 2007 года.
PyPy carbonpython (недоступная ссылка). Дата обращения: 24 июля 2007. Архивировано 12 сентября 2007 года.
Pyrex. Дата обращения: 3 февраля 2007. Архивировано 26 сентября 2018 года.
Cython: C-Extensions for Python. Дата обращения: 28 июля 2007. Архивировано 11 августа 2007 года.
Архивированная копия (недоступная ссылка). Дата обращения: 1 июня 2006. Архивировано 4 августа 2018 года.
bpython interpreter. Дата обращения: 17 февраля 2011. Архивировано 11 мая 2011 года.
Васильев Денис Алексеевич. Методические особенности изучения языка Python школьниками // Символ науки. — 2017. — № 1.
Mark Lutz. Learning Python: Powerful Object-Oriented Programming (англ.). — O'Reilly Media, Inc., 2009-10-06. — P. 7—8. — 1218 p. — ISBN 978-1-4493-7932-2. Архивная копия от 10 апреля 2021 на Wayback Machine
Jukka Lehtosalo. Our journey to type checking 4 million lines of Python (англ.). dropbox.tech. Dropbox (5 сентября 2019). Дата обращения: 22 сентября 2020. Архивировано 22 сентября 2020 года.
Python in production engineering. Дата обращения: 21 января 2017. Архивировано 2 февраля 2017 года.
What Powers Instagram: Hundreds of Instances, Dozens of Technologies. Дата обращения: 21 января 2017. Архивировано 9 июня 2021 года.
Grumpy: Go running Python! Архивная копия от 20 января 2017 на Wayback Machine — статья в Google Open Source Blog
Christina Cardoza. Google recommits to the Python ecosystem, SD Times (12.02.2021). Архивировано 25 февраля 2021 года. Дата обращения 4 апреля 2021.
Welcoming Google as a Visionary Sponsor of the PSF, News from the Python Software Foundation (11.02.2021). Архивировано 9 апреля 2021 года. Дата обращения 4 апреля 2021.
Google Cloud финансирует экосистему Python, Издательство «Открытые системы» (02.03.2021). Архивировано 9 июня 2021 года. Дата обращения 4 апреля 2021.
Eilif Muller, James A. Bednar, Markus Diesmann, Marc-Oliver Gewaltig, Michael Hines. Python in neuroscience (англ.) // Frontiers in Neuroinformatics. — 2015. — 14 April (vol. 9). — ISSN 1662-5196. — doi:10.3389/fninf.2015.00011. Архивировано 30 ноября 2020 года.
Scripting & Extending Blender : Introduction (англ.). Blender Manual. Blender. Дата обращения: 21 сентября 2020. Архивировано 21 сентября 2020 года.
Python Scripting (англ.). www.sidefx.com. Дата обращения: 27 сентября 2020. Архивировано 29 сентября 2020 года.
Building a plugin for QGIS (англ.). Geographic Informations Systems (GIS) Program. National Center for Atmospheric Research. Дата обращения: 23 сентября 2020. Архивировано 23 сентября 2020 года.
Jonathan Thomas. OpenShot Video Editor for Windows, Mac, and Linux (англ.). Kickstarter (4 марта 2020). Дата обращения: 23 сентября 2020. Архивировано 23 сентября 2020 года.
Using GNS3 with Fedora (англ.) ?. Fedora Magazine (28 августа 2019). Дата обращения: 22 сентября 2020. Архивировано 1 октября 2020 года.
Ultimaker Cura GitHub. Дата обращения: 19 сентября 2020. Архивировано 17 сентября 2020 года.
natol Locker. 2020 Best 3D Printer Slicer Software (англ.). All3DP (2 января 2020). — «The list is sorted by popularity (via Alexa rank)». Дата обращения: 24 сентября 2020. Архивировано 13 августа 2020 года.
Peter Jurica, Cees Van Leeuwen. OMPC: an open-source MATLAB®-to-Python compiler (англ.) // Frontiers in Neuroinformatics. — 2009. — Т. 3. — ISSN 1662-5196. — doi:10.3389/neuro.11.005.2009. Архивировано 29 ноября 2020 года.
Veusz Development (англ.). Veusz. Github Pages. Дата обращения: 2 октября 2020. Архивировано 2 октября 2020 года.
Fisher, M. Plot with a purpose : [арх. 2 октября 2020] // Writing for Conservation : [англ.]. — Fauna & Flora International, Cambridge, 2019.
The Astropy Collaboration, A. M. Price-Whelan, B. M. Sipőcz, H. M. Günther, P. L. Lim, S. M. Crawford, S. Conseil, D. L. Shupe, M. W. Craig, N. Dencheva. The Astropy Project: Building an Open-science Project and Status of the v2.0 Core Package : [англ.] : [арх. 3 октября 2020] // The Astronomical Journal. — 2018. — Т. 156, вып. 3 (24 August). — С. 123. — ISSN 1538-3881. — doi:10.3847/1538-3881/aabc4f.
The Google Mock class generator README. Google Test. github.com. Дата обращения: 3 февраля 2019. Архивировано 9 июня 2021 года.
Noah Gift, Jeremy M. Jones. Python for Unix and Linux System Administration. — ISBN 978-0-596-51582-9.
Литература
Лучано Рамальо. Python. К вершинам мастерства : [рус.] = Fluent Python. O’Reilly, 2015 : [пер. с англ.]. — ДМК Пресс, 2016.
Кеннет Рейтц, Таня Шлюссер. Автостопом по Python : [рус.] = The Hitchhiker`s Guide to Python : [пер. с англ.]. — Издательский дом «Питер», 2017. — ISBN 9785496030236.
David M. Beazley. Python Essential Reference. — 4th Edition. — Addison-Wesley Professional, 2009. — 717 с. — ISBN 978-0672329784.
Jan Palach. Parallel Programming with Python. — Packt Publishing Ltd, 2014.
Яворски Михал, Зиаде Тарек. Python. Лучшие практики и инструменты : [рус.] = Expert Python Programming : [пер. с англ.]. — Издательский дом «Питер», 2021.
Федоров, Д. Ю. Программирование на языке высокого уровня Python. — Москва: Издательство Юрайт, 2022. — 210 с. — (Высшее образование). — ISBN 978-5-534-14638-7.
Ссылки
Python:

Книги в Викиучебнике

Тексты в Викитеке

Медиафайлы на Викискладе
Официальный сайт (англ.)
